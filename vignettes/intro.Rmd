---
title: "Grouped Hyperframe"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(rmarkdown.html_vignette.check_title = FALSE)
```

```{r setup}
library(groupedHyperframe)
library(survival) # to help ?spatstat.geom::hyperframe understand ?survival::Surv object
```

# Introduction

Development version of package `groupedHyperframe` is hosted on [Github](https://github.com/tingtingzhan/groupedHyperframe).

Development versions of `spatstat` family of packages are required.
```{r eval = FALSE}
devtools::install_github('spatstat/spatstat'); packageDate('spatstat')
devtools::install_github('spatstat/spatstat.data'); packageDate('spatstat.data')
devtools::install_github('spatstat/spatstat.explore'); packageDate('spatstat.explore')
devtools::install_github('spatstat/spatstat.geom'); packageDate('spatstat.geom')
devtools::install_github('spatstat/spatstat.linnet'); packageDate('spatstat.linnet')
devtools::install_github('spatstat/spatstat.model'); packageDate('spatstat.model')
devtools::install_github('spatstat/spatstat.random'); packageDate('spatstat.random')
devtools::install_github('spatstat/spatstat.sparse'); packageDate('spatstat.sparse')
devtools::install_github('spatstat/spatstat.univar'); packageDate('spatstat.univar')
devtools::install_github('spatstat/spatstat.utils'); packageDate('spatstat.utils')
```


# Methods

## `groupedHyperframe` Object

The `groupedHyperframe` object inherits from `spatstat.geom::hyperframe` object, in a similar fashion as `nlme::groupedData` inherits from `base::data.frame`.
In addition to `spatstat.geom::hyperframe` object,

* `attr(., 'group')`, a formula to specify the grouping structure



### With one-and-only-one `spatstat.geom::ppp`-hypercolumn

Function `grouped_ppp()` creates a `groupedHyperframe` with one-and-only-one marked point pattern (`spatstat.geom::ppp`) hypercolumn.  

Following example shows that the argument `formula` specifies

* the marks (e.g., `numeric` mark *`hladr`* and `spatstat.geom::is.multitype` mark *`phenotype`*) on the left-hand-side
* additional predictors and/or endpoints (e.g., *`OS`*, *`gender`* and *`age`*) before the `|` separator on the right-hand-side
* (nested) grouping structure (e.g., *`image_id`* nested in *`patient_id`*) after the `|` separator on the right-hand-side. See `nlme::groupedData` for a thorough discussion. 

```{r}
(s = grouped_ppp(formula = hladr + phenotype ~ OS + gender + age | patient_id/image_id, 
                 data = wrobel_lung))
```

Parameter `coords` of function `grouped_ppp()` specifies the column name of $x$- and $y$-coordinates in the input `data`. Default `coords = ~ x + y` indicates using `data$x` and `data$y` for $x$- and $y$-coordinates, respectively.  Users may use `coords = FALSE` for input `data` without $x$- and $y$-coordinates. In this case, the coordinates are filled with randomly generated numbers, and the output has a `pseudo.ppp` hypercolumn.

```{r}
Ki67_ = Ki67 |> within.data.frame(expr = {
  x = y = NULL # remove x- and y-coordinates
})
(s_a = grouped_ppp(Ki67 ~ Surv(recfreesurv_mon, recurrence) + race + age | patientID/tissueID, 
                  data = Ki67_, coords = FALSE))
```


## Batch Processes on `ppp`-Hypercolumn 

Batch processes could be applied to the one-and-only-one `ppp`-hypercolumn of a `hyperframe`.  

### Batch processes that return `fv`-hypercolumn

Batch process(es) that return a `spatstat.explore::fv.object`-hypercolumn include

* `Emark_()`, from function `spatstat.explore::Emark()`, applicable to the `numeric` marks (e.g., *`hladr`*) in the `ppp`-hypercolumn
* `Vmark_()`, from function `spatstat.explore::Vmark()`, applicable to the `numeric` marks
* `markcorr_()`, from function `spatstat.explore::markcorr()`, applicable to the `numeric` marks
* `markvario_()`, from function `spatstat.explore::markvario()`, applicable to the `numeric` marks
* `Gcross_()`, from function `spatstat.explore::Gcross()`, applicable to the `multitype` marks (e.g., *`phenotype`*) in the `ppp`-hypercolumn
* `Kcross_()`, from function `spatstat.explore::Kcross()`, applicable to the `multitype` marks
* `Jcross_()`, from function `spatstat.explore::Jcross()`, applicable to the `multitype` marks

### Batch processes that return `numeric`-hypercolumn

Batch process(es) that return a `numeric`-hypercolumn include

* `nncross_()`, from function `spatstat.geom::nncross.ppp(., what = 'dist')`, applicable to the `multitype` marks

### Batch processes: Example

Following example shows that the batch process(es) may be applied to a `groupedHyperframe` in a pipeline (`|>`).

```{r}
r = seq.int(from = 0, to = 250, by = 10)
out = s |>
  Emark_(r = r, correction = 'best') |> # slow
  # Vmark_(r = r, correction = 'best') |> # slow
  # markcorr_(r = r, correction = 'best') |> # slow
  # markvario_(r = r, correction = 'best') |> # slow
  Gcross_(i = 'CK+.CD8-', j = 'CK-.CD8+', r = r, correction = 'best') |> # fast
  # Kcross_(i = 'CK+.CD8-', j = 'CK-.CD8+', r = r, correction = 'best') |> # fast
  nncross_(i = 'CK+.CD8-', j = 'CK-.CD8+', correction = 'best') # fast
```

The returned `groupedHyperframe` has new hypercolumns

* `fv`-hypercolumn *`hladr.E`*, created by function `Emark()` on `numeric` mark *`hladr`*
* `fv`-hypercolumn *`phenotype.G`*, created by function `Gcross_()` on `multitype` mark *`phenotype`*
* `numeric`-hypercolumn *`phenotype.nncross`*, created by function `nncross_()` on `multitype` mark *`phenotype`*

```{r}
out
```

## Aggregation Over Nested Grouping Structure

When nested grouping structure `~g1/g2/.../gm` is present, we may aggregate over the

* `fv`-hypercolumn(s)
* `numeric`-hypercolumn(s)
* `numeric` marks inside the `ppp`-hypercolumn

by either one of the grouping levels `~g1`, `~g2`, ..., or `~gm`. If the lowest grouping `~gm` is specified, then no aggregation is performed.

The returned object of various aggregation functions, `aggregate_fv()`, `aggregate_quantile()` and `aggregate_kerndens()`, is `base::data.frame` instead of `spatstat.geom::hyperframe`.  This is because the aggregated results are stored in `matrix`-columns, while `spatstat.geom::hyperframe` does not support `matrix`-column.


### `fv`-hypercolumn(s): function value and cumulative trapezoid area

Function `aggregate_fv()` aggregates 

* the function values `value`, i.e., the black-solid-curve of `spatstat.explore::plot.fv`;
  + `matrix`-column *`hladr.E.value`*, aggregated function value from `fv`-hypercolumn *`hladr.E`*
  + `matrix`-column *`phenotype.G.value`*, aggregated function value from `fv`-hypercolumn *`phenotype.G`*
* the cumulative trapezoid area under the black-solid-curve `cumarea` (via function `pracma::cumtrapz`).
  + `matrix`-column *`hladr.E.cumarea`*, aggregated cumulative trapezoid area under function value from `fv`-hypercolumn *`hladr.E`*
  + `matrix`-column *`phenotype.G.cumarea`*, aggregated cumulative trapezoid area under function value from `fv`-hypercolumn *`phenotype.G`*

```{r}
afv = out |>
  aggregate_fv(by = ~ patient_id, f_aggr_ = 'mean')
nrow(afv) # number of patients
names(afv)
dim(afv$hladr.E.cumarea) # N(patient) by length(r)
```

### `numeric`-hypercolumn(s) and `numeric` mark(s) inside `ppp`-hypercolumn

Function `aggregate_quantile()` aggregates 

* the `stats::quantile` of the `numeric`-hypercolumn(s)
  + `matrix`-column *`phenotype.nncross.quantile`*, aggregated `quantile` of `numeric`-hypercolumn *`phenotype.nncross`*
* the `quantile` of the `numeric` mark(s) inside the `ppp`-hypercolumn.
  + `matrix`-column *`hladr.quantile`*, aggregated `quantile` of `numeric` mark *`hladr`* in `ppp`-hypercolumn

```{r}
q = out |>
  aggregate_quantile(by = ~ patient_id, probs = seq.int(from = 0, to = 1, by = .1))
nrow(q)
names(q)
dim(q$phenotype.nncross.quantile)
dim(q$hladr.quantile)
```

Function `aggregate_kerndens()` aggregates 

* the kernel density `stats::density.default()$y` from the `numeric`-hypercolumn(s), 
  + `matrix`-column *`phenotype.nncross.kerndens`*, aggregated kernel density of `numeric`-hypercolumn *`phenotype.nncross`*
* the kernel density of the `numeric` mark(s) inside the `ppp`-hypercolumn.
  + `matrix`-column *`hladr.kerndens`*, aggregated kernel density of `numeric` mark *`hladr`* in `ppp`-hypercolumn

```{r}
(mdist = out$phenotype.nncross |> unlist() |> max())
d = out |> 
  aggregate_kerndens(by = ~ patient_id, from = 0, to = mdist)
nrow(d)
names(d)
dim(d$phenotype.nncross.kerndens)
```