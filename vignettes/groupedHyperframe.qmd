---
title: "Grouped Hyper Data Frame"
author: Tingting Zhan
date: "`r format(Sys.time(), 'Last updated %d %B, %Y')`"
format: 
  html:
    page-layout: full
    html-math-method: katex
toc: true
toc-location: left
toc-depth: 4
toc-title: ''
editor: source
bibliography: groupedHyperframe.bib
knitr:
  opts_chunk: 
    collapse: true
    comment: "#>" 
vignette: >
  %\VignetteIndexEntry{intro}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

```{=html}
<!--
`r knitr::asis_output('\U1f5dd')`
seems not needed
-->
```

# Introduction

This vignette of R package **`groupedHyperframe`** ([CRAN](https://cran.r-project.org/package=groupedHyperframe), [Github](https://github.com/tingtingzhan/groupedHyperframe), [RPubs](https://rpubs.com/tingtingzhan/groupedHyperframe)) documents

-   the creation of `groupedHyperframe` object,
-   the batch processes for a `hyperframe` and/or `groupedHyperframe`, and
-   the aggregation of various statistics over (nested) grouping structure.

R terminology might be different from that of mathematics and statistics. Please refer to Appendix @sec-terms for explanation and reference of the terms and abbreviations used in this vignette.

Package **`groupedHyperframe`** `Enhances` the **`spatstat.*`** family of packages [@spatstat15; @spatstat05], specifically

-   **`spatstat.explore`** (dev v`r packageVersion('spatstat.explore')`), with
    -   new methods for `fv.object`
    -   batch processes to return a hypercolumn of `fv.object`s
-   **`spatstat.geom`** (dev v`r packageVersion('spatstat.geom')`), with
    -   a new derived class of `hyperframe`
    -   new methods for `ppp.object` and `hyperframe`

Package **`groupedHyperframe`** `Imports` packages

-   **`cli`** [@cli, v`r packageVersion('cli')`], for attractive command line interfaces
-   `r '\U1f5dd'` **`GET`** [@GET, v`r packageVersion('GET')`], key dependency, for global envelope test
-   **`ggplot2`** [@ggplot2, v`r packageVersion('ggplot2')`], **`geomtextpath`** [@geomtextpath, v`r packageVersion('geomtextpath')`], for educational visualization
-   `r '\U1f5dd'` **`matrixStats`** [@matrixStats, v`r packageVersion('matrixStats')`], key dependency, for matrix arithmetic
-   **`parallel`** shipped with `r R.version$version.string`, for parallel computing
-   `r '\U1f5dd'` **`pracma`** [@pracma, v`r packageVersion('pracma')`], key dependency, for (cumulative) trapezoidal integration
-   `r '\U1f5dd'` **`SpatialPack`** [@SpatialPack, v`r packageVersion('SpatialPack')`], key dependency, for Tj√∏stheim's coefficient of spatial association
-   `r '\U1f5dd'` **`spatstat.explore`** (dev v`r packageVersion('spatstat.explore')`), **`spatstat.geom`** (dev v`r packageVersion('spatstat.geom')`), **`spatstat.random`** (dev v`r packageVersion('spatstat.random')`), key dependency, for spatial statistics

Package **`groupedHyperframe`** `Suggests` packages

-   `r '\U1f5dd'` **`spatstat.data`** (dev v`r packageVersion('spatstat.data')`), key suggest, for example spatial data set
-   `r '\U1f5dd'` **`survival`** [@survival, v`r packageVersion('survival')`], key suggest, <!--for function `survival:::as.data.frame.Surv()`--> to help `hyperframe` understand `Surv` object

## Prerequisite

Package **`groupedHyperframe`** requires R version 4.5.0 (released 2025-04-11) or higher ([macOS](https://cran.r-project.org/bin/macosx/), [Windows](https://cran.r-project.org/bin/windows/base/)). An Integrated Development Environment (IDE), e.g., [RStudio](https://posit.co/download/rstudio-desktop/) or [Positron](https://positron.posit.co/download.html), is not required, but highly recommended. This vignette is created under `r R.version$version.string` using packages **`knitr`** [@knitr, v`r packageVersion('knitr')`], **`quarto`** [@quarto, v`r packageVersion('quarto')` with [Quarto](https://quarto.org/docs/get-started/) v`r quarto::quarto_version()`] and **`rmarkdown`** [@rmarkdown, v`r packageVersion('rmarkdown')`].

```{r}
#| code-fold: true
#| code-summary: "Environment on author's computer"
Sys.info()[c('sysname', 'release', 'machine')]
R.version
```

Package **`groupedHyperframe`** requires the development versions of the **`spatstat.*`** family of packages.

```{r}
#| eval: false
remotes::install_github('spatstat/spatstat', upgrade = 'always')
remotes::install_github('spatstat/spatstat.data', upgrade = 'always')
remotes::install_github('spatstat/spatstat.explore', upgrade = 'always')
remotes::install_github('spatstat/spatstat.geom', upgrade = 'always')
remotes::install_github('spatstat/spatstat.linnet', upgrade = 'always')
remotes::install_github('spatstat/spatstat.model', upgrade = 'always')
remotes::install_github('spatstat/spatstat.random', upgrade = 'always')
remotes::install_github('spatstat/spatstat.sparse', upgrade = 'always')
remotes::install_github('spatstat/spatstat.univar', upgrade = 'always')
remotes::install_github('spatstat/spatstat.utils', upgrade = 'always')
```

Experimental (and maybe unstable) features are released *extremely frequently* to [Github](https://github.com/tingtingzhan/groupedHyperframe). [Active developers should use the Github version; suggestions and bug reports are welcome!]{style="background-color: #FFFF00"} Stable releases to [CRAN](https://CRAN.R-project.org/package=groupedHyperframe) are typically updated every 2 to 3 months, or when the authors have an upcoming manuscript in the peer-reviewing process.

```{r}
#| eval: false
remotes::install_github('tingtingzhan/groupedHyperframe')
```

```{r}
#| eval: false
#| code-fold: true
#| code-summary: "Developers, do NOT use the CRAN version!"
utils::install.packages('groupedHyperframe') # Developers, do NOT use!!
```

## Getting Started

Examples in this vignette require that the `search` path has

```{r}
#| message: false
library(groupedHyperframe)
library(survival) # to help hyperframe understand Surv object
```

```{r}
#| echo: false
op = par(no.readonly = TRUE)
#options(mc.cores = 1L) # for CRAN submission
```

## Acknowledgement

This work is supported by National Institutes of Health, U.S. Department of Health and Human Services grants

-   R01CA222847 ([I. Chervoneva](https://orcid.org/0000-0002-9104-4505), [T. Zhan](https://orcid.org/0000-0001-9971-4844), and [H. Rui](https://orcid.org/0000-0002-8778-261X))
-   R01CA253977 (H. Rui and I. Chervoneva).

# Grouped Hyper Data Frame {#sec-groupedHyperframe}

An `S3` class `hyperframe`, for **hyper data frame**, is defined in package **`spatstat.geom`**. A `hyperframe` contains columns either as `vector`s like in a `data.frame`, or as `list`s of objects of the same class, a.k.a., the `hypercolumns`. The `hyperframe` data structure is particularly useful in spatial analysis, e.g., with medical images, where the spatial information in each image would be represented by one element in a hypercolumn. For example, example data *`demohyper`* from package **`spatstat.data`** contains a `factor` column *`Group`*, a point-pattern `ppp`-hypercolumn *`Points`*, and a pixel image `im`-hypercolumn *`Image`*. Several `S3` method dispatches to the `hyperframe` class behave *very differently* from their counterpart in vanilla R, see Appendix @sec-hyperframe.

```{r}
spatstat.data::demohyper
```

We introduce a new `S3` class `groupedHyperframe`, for **grouped hyper data frame**, which `inherits` from the `hyperframe` class. The derived class `groupedHyperframe` has additional `attributes`

-   `attr(., 'group')`, a one-sided `formula` of the (nested) grouping structure, e.g., *`~patient/image`* when each patient has one or more images. The grammar of the nested grouping structure $g_1/.../g_m$ (`~g1/.../gm`) is explained in section *Details* of[`stats::formula`](https://search.r-project.org/R/refmans/stats/html/formula.html) documentation. This grammar is also made well known by the parameter `random` of functions `nlme::lme()` and `nlme::nlme()`. In fact, the 'grouped' extension of a `hyperframe` is inspired by the `nlme::groupedData` class which inherits from `data.frame` [@nlme]. Appendix @sec-nestedGroup outlines some experimental usage of nested grouping structure that are subject to change.

The `S3` generic function `as.groupedHyperframe()` converts objects of various classes into a `groupedHyperframe`. Functions `aggregate_*()` aggregates the hypercolumns in a `groupedHyperframe` at either one of the nested grouping levels $g_1,\cdots,g_{m-1}$. Aggregation at the lowest grouping level $g_m$ is ignored, i.e., no aggregation to be performed. Available aggregation methods are the point-wise minima `base::pmin()`, maxima `base::pmax()`, means `pmean()` (default) and medians `pmedian()`.

## From `data.frame`

The `S3` method dispatch `as.groupedHyperframe.data.frame()` converts a `data.frame` with substantial amount of duplicated information into a `groupedHyperframe`. This function

1.  inspects the input `data.frame` by the user-specified (nested) `group`ing structure;
2.  identifies the column(s) with *non-identical elements* within the lowest group, and converts them into hypercolumn(s).

We have a toy data example *`wrobel_lung`* in package **`groupedHyperframe`** originally from Dr. [Julia Wrobel](https://sph.emory.edu/profile/faculty/julia-wrobel).  In the following example, consider a subset of *`wrobel_lung0`* with the only non-identical column *`hladr`* in the lowest group *`image_id`* of the nested grouping structure *`~patient_id/image_id`*.

```{r}
wrobel_lung0 = wrobel_lung |>
  within.data.frame(expr = {
    x = y = NULL
    dapi = phenotype = tissue = NULL
    stage_numeric = pack_years = adjuvant_therapy = NULL # to save console space
  })
```

```{r}
wrobel_lung0 |> head()
```

By converting *`wrobel_lung0`* into a `groupedHyperframe`, the numeric *`hladr`* values from each *`~patient_id/image_id`* are converted into elements of the numeric-hypercolumn *`hladr`* in the returned object *`wrobel_lung0g`*. Each row of a `groupedHyperframe` represents the lowest group of the nested grouping structure. The `S3` method dispatch `print.groupedHyperframe()` highlights the nested grouping structure, number of clusters at each grouping level, as well as the first 10 (or less) rows of the `groupedHyperframe`.

```{r}
(wrobel_lung0g = wrobel_lung0 |> as.groupedHyperframe(group = ~ patient_id/image_id))
```

Converting a `data.frame` with substantial amount of duplicated information into a `groupedHyperframe` greatly reduces the memory allocation. A `groupedHyperframe`, however, would not reduce much the `save`d `file.size` compared to a `data.frame`, if `xz` compression is used for both.

```{r}
#| code-fold: true
#| code-summary: "Reducing memory allocation"
unclass(object.size(wrobel_lung0g) / object.size(wrobel_lung0))
```

```{r}
#| code-fold: true
#| code-summary: "Not reducing `xz`-compressed file size"
f_g = tempfile(fileext = '.rds')
wrobel_lung0g |> saveRDS(file = f_g, compress = 'xz')
f = tempfile(fileext = '.rds')
wrobel_lung0 |> saveRDS(file = f, compress = 'xz')
file.size(f_g) / file.size(f)
```

### Aggregate numeric-hypercolumn

Function `aggregate_quantile()` aggregates the `quantile`s of each element in the numeric-hypercolumn, e.g., *`hladr`* in *`wrobel_lung0g`*, by point-wise means (default of parameter `f_aggr_`) at the biologically independent group, e.g., *`~patient_id`*. The returned object is a `hyperframe` instead of a `groupedHyperframe`, as we have *one* aggregated *`hladr.quantile`* per *`~patient_id`*, thus eliminates the need for a grouping structure. The R console output is taken care of by the `S3` method dispatch `spatstat.geom::print.hyperframe()`.

```{r}
#| message: false
wrobel_lung0g |>
  aggregate_quantile(by = ~ patient_id, probs = seq.int(from = .01, to = .99, by = .01))
```

## From `hyperframe`

The `S3` method dispatch `as.groupedHyperframe.hyperframe()` converts a `hyperframe`, e.g., from package **`spatstat.data`**, into a `groupedHyperframe`. This function simply inspects and adds a (nested) grouping structure to the input `hyperframe`. In the following example, we inspect the data set *`osteo`* from package **`spatstat.data`**, which has the serial number of sampling volume `brick` nested in the bone sample `id`, and add the nested grouping structure `~id/brick` to it.

```{r}
spatstat.data::osteo |> 
  as.groupedHyperframe(group = ~ id/brick)
```

In this vignette, we do not place much emphasize on the objects provided in package **`spatstat.data`**, for now.

# Grouping `ppp`-Hypercolumn

In this section, we first introduce the creation of a `groupedHyperframe` with *one-and-only-one* point pattern (`ppp`) hypercolumn. Then, we discuss

-   the batch processes of spatial point pattern analyses on the *one-and-only-one* `ppp`-hypercolumn of a `hyperframe` (and/or `groupedHyperframe`). These batch processes are not intended for a `hyperframe` (and/or `groupedHyperframe`) with multiple `ppp`-hypercolumns in the foreseeable future, as that would require checking for name clashes in the `marks` from multiple `ppp`-hypercolumns.
-   the aggregation of batch-process-returns over the nested grouping structure.

Function `grouped_ppp()` creates a `groupedHyperframe` with *one-and-only-one* `ppp`-hypercolumn. In the following example, the argument `formula` takes form of `<marks> ~ <variable.of.interest> | <group>`, specifically,

-   the point pattern `marks`, e.g., numeric mark *`hladr`* and `multitype` mark *`phenotype`*, on the left-hand-side
-   the additional predictors and/or endpoints for downstream analysis, e.g., *`OS`*, *`gender`* and *`age`*, before the `|` separator on the right-hand-side
-   the (nested) grouping structure, e.g., *`image_id`* nested in *`patient_id`*, after the `|` separator on the right-hand-side.

```{r}
(s = wrobel_lung |>
   grouped_ppp(formula = hladr + phenotype ~ OS + gender + age | patient_id/image_id))
```

## Batch processes {#sec-batch}

### Return of `fv`-hypercolumn

In this section, we discuss the batch processes that return a function value table (`fv`) hypercolumn, i.e., a hypercolumn which consists of a `list` of `fv.object`s.

| Batch Process | Workhorse in package **`spatstat.explore`** | `fv`-hypercolumns Suffix |
|------------------------|------------------------|------------------------|
| `Emark_()` and `Vmark_()` | [`Emark` and `Vmark`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Emark.html), conditional mean $E(r)$ and variance $V(r)$, diagnostics for dependence between the points and the marks [@Emark] | `.E` and `.V` |
| `markcorr_()` | [`markcorr`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/markcorr.html), marked correlation $k_{mm}(r)$ or generalized mark correlation $k_f(r)$ [@markcorr] | `.k` |
| `markvario_()` | [`markvario`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/markvario.html), mark variogram $\gamma(r)$ [@markvario] | `.gamma` |
| `Kmark_()` | [`Kmark`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Kmark.html), mark-weighted $K_f(r)$ function [@Kmark] | `.K` |

: Batch processes applicable to numeric `marks`

| Batch Process | Workhorse in package **`spatstat.explore`** | `fv`-hypercolumns Suffix |
|------------------------|------------------------|------------------------|
| `Gcross_()` | [`Gcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Gcross.html), multitype nearest-neighbour distance $G_{ij}(r)$ | `.G` |
| `Kcross_()` | [`Kcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Kcross.html), multitype $K_{ij}(r)$ | `.K` |
| `Jcross_()` | [`Jcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Jcross.html), multitype $J_{ij}(r)$ [@Jcross] | `.J` |
| `Lcross_()` | [`Lcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Lcross.html), multitype $L_{ij}(r)=\sqrt{\frac{K_{ij}(r)}{\pi}}$ | `.L` |

: Batch processes applicable to `multitype` `marks`

### Return of numeric-hypercolumn

In this section, we discuss the batch processes that return a numeric hypercolumn, i.e., a hypercolumn which consists of a `list` of numeric `vector`s.

| Batch Process | Workhorse in package **`spatstat.geom`** | Applicable to | numeric-hypercolumns Suffix |
|------------------|------------------|------------------|------------------|
| `nncross_()` | [`nncross.ppp`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/nncross.html)`(., what = 'dist')`, nearest neighbour distance | `multitype` marks | `.nncross` |

### In a pipeline

Multiple batch processes may be applied to a `hyperframe` (and/or `groupedHyperframe`) in a pipeline using the native pipe operator `|>` introduced since R version 4.1.0.

```{r}
r = seq.int(from = 0, to = 250, by = 10)
out = s |>
  Emark_(r = r, correction = 'none') |> # slow
  # Vmark_(r = r, correction = 'none') |> # slow
  # markcorr_(r = r, correction = 'none') |> # slow
  # markvario_(r = r, correction = 'none') |> # slow
  # Kmark_(r = r, correction = 'none') |> # fast
  Gcross_(i = 'CK+.CD8-', j = 'CK-.CD8+', r = r, correction = 'none') |> # fast
  # Kcross_(i = 'CK+.CD8-', j = 'CK-.CD8+', r = r, correction = 'none') |> # fast
  nncross_(i = 'CK+.CD8-', j = 'CK-.CD8+', correction = 'none') # fast
```

The `message` of "Legal $r_\text{max}$" provides the indices in the `ppp`-hypercolumn, i.e., the row indices of the `hyperframe`, where the legal $r_\text{max}$ (see Appendix @sec-legal_rmax) is smalller than the user-specified $r_\text{max}$. The returned `hyperframe` (and/or `groupedHyperframe`) has

-   `fv`-hypercolumn *`hladr.E`*, created by function `Emark_()` on numeric mark *`hladr`*
-   `fv`-hypercolumn *`phenotype.G`*, created by function `Gcross_()` on `multitype` mark *`phenotype`*
-   numeric-hypercolumn *`phenotype.nncross`*, created by function `nncross_()` on `multitype` mark *`phenotype`*

```{r}
out
```

## Truncated Aggregation

In this section, we discuss the aggregation over nested grouping structure.

### Of `fv`-hypercolumn(s)

<!--
> AuC_E in 2021 paper is created by `<groupedHyperframe> |> Emark_() |> aggregate_fv()`
-->


Function `aggregate_fv()` performs (truncated) aggregation of

-   *`<mark>.<fv>.value`*, the *function values*, i.e., the black-solid-curve (see Appendix @sec-blackSolidCurve) determined by function `spatstat.explore::plot.fv()`
-   *`<mark>.<fv>.cumtrapz`*, the *cumulative trapezoidal integration* under the black-solid-curve
-   *`<mark>.<fv>.cumvtrapz`*, the *cumulative average vertical height of trapezoidal integration* (see Appendix @sec-vtrapz) under the black-solid-curve

When a user-specified $r_\text{max}$ is provided to a batch process (in @sec-batch) on *all* `ppp.object`s in the `ppp`-hypercolumn, inevitably some of the `fv`-returns may contain exceptional/illegal function values (see Appendix @sec-legal_rmax). In this case, the aggregation is *truncated* at the minimum legal $r_\text{max}$ of the `fv.object`s in each `fv`-hypercolumn. 

In the following example, we have

-   numeric-hypercolumns *`hladr.E.value`*, *`hladr.E.cumtrapz`* and *`hladr.E.cumvtrapz`* from `fv`-hypercolumns *`hladr.E`*. Function values from all `fv.object`s in the `fv`-hypercolumns *`hladr.E`* are legal, therefore, this aggregation is not truncated.

-   numeric-hypercolumns *`phenotype.G.value`*, *`phenotype.G.cumtrapz`* and *`phenotype.G.cumvtrapz`* from `fv`-hypercolumns *`phenotype.G`*. This aggregation is *truncated* at the minimum legal $r_\text{max}=240$ of the `fv.object`s in the `fv`-hypercolumn *`phenotype.G`*.

```{r}
(afv = out |>
  aggregate_fv(by = ~ patient_id, f_aggr_ = pmean))
```

User may specify an $r_\text{max}$ for truncation using the argument `rmax` of function `aggregate_fv()`.

```{r}
#| results: hide
out |>
  aggregate_fv(by = ~ patient_id, f_aggr_ = pmean, rmax = 220)
```

If the user-specified $r_\text{max}$ is greater than the minimum legal $r_\text{max}$, the user's $r_\text{max}$ will be ignored.

```{r}
#| results: hide
out |>
  aggregate_fv(by = ~ patient_id, f_aggr_ = pmean, rmax = 260)
```

Each one of the numeric-hypercolumns contains tabulated values on the common grid of $r$. One "slice" of the hypercolumn *`hladr.E.cumtrapz`* at $r=50$ may be extracted by calling the `S3` method dispatch `spatstat.geom::with.hyperframe()` (which behaves *very differently* from function `base::with.default()`, see Appendix @sec-hyperframe),

```{r}
afv |>
  with(expr = {
    hladr.E.cumtrapz['50']
  })
```

Alternatively, the 5th slice (which corresponds to $r=50$, as the cumulative trapzoidal integration starts at the second index $r=10$ instead of the first index $r=0$) of the hypercolumn *`hladr.E.cumtrapz`* may be extracted by

```{r}
afv |>
  with(expr = {
    hladr.E.cumtrapz[5L]
  })
```

### Of numeric-hypercolumn, and numeric marks in `ppp`-hypercolumn

#### On `quantile`s

Function `aggregate_quantile()` aggregates the `quantile`s of the numeric-hypercolumns and the numeric marks in the `ppp`-hypercolumn. In the following example, we have

-   numeric-hypercolumn *`phenotype.nncross.quantile`*, the aggregated `quantile`s of numeric-hypercolumn *`phenotype.nncross`*.
-   numeric-hypercolumn *`hladr.quantile`*, the aggregated `quantile`s of numeric mark *`hladr`* in `ppp`-hypercolumn.

```{r}
#| message: false
out |>
  aggregate_quantile(by = ~ patient_id, probs = seq.int(from = 0, to = 1, by = .1))
```

In this package, we include a `groupedHyperframe` example ***`Ki67`*** with a `ppp`-hypercolumn *`ppp.`* and a nested grouping structure *`~patientID/tissueID`*.

```{r}
data(Ki67, package = 'groupedHyperframe')
Ki67
```

We use function `aggregate_quantile()` to aggregate the `quantile`s of the numeric `marks`, i.e., the log-transformed Ki67 intensities, from each element of the `ppp`-hypercolumn *`ppp.`* at the second-lowest group `~patientID`.

```{r}
#| message: false
Ki67 |>
  aggregate_quantile(by = ~ patientID, probs = seq.int(from = .01, to = .99, by = .01)) |> 
  head()
```

Users are encouraged to learn more about the applications of the aggregated quantiles of ***`Ki67`*** data from package **`hyper.gam`** vignettes ([RPubs](https://rpubs.com/tingtingzhan/hyper_gam), [CRAN](https://CRAN.R-project.org/package=hyper.gam/vignettes/applications.html)), section *Quantile Index*, and our peer-reviewed publications

```{r}
#| echo: false
#| warning: false
bib_QI = bibentry(
  bibtype = 'article',
  title = 'Quantile Index predictors using R package hyper.gam',
  author = c('Tingting Zhan', 'Misung Yi', 'Inna Chervoneva' ),
  journal = 'Bioinformatics',
  pages = 'btaf430',
  year = '2025', 
  month = '07',
  issn = '1367-4811',
  doi = '10.1093/bioinformatics/btaf430'
)
```

> `r bib_QI |> format(style = 'text') |> gsub(pattern = '\n', replacement = ' ', x = _)`

```{r}
#| echo: false
#| comment: ''
bib_QI |> toBibtex()
```

and @Yi25; @Yi23a; @Yi23b.

#### On kernel densities

Function `aggregate_kerndens()` aggregates the kernel density of the numeric-hypercolumns and the numeric marks in the `ppp`-hypercolumn.

In the following example, we have

-   numeric-hypercolumn *`phenotype.nncross.kerndens`*, the aggregated kernel densities of numeric-hypercolumn *`phenotype.nncross`*.
-   numeric-hypercolumn *`hladr.kerndens`*, the aggregated kernel densities of numeric mark *`hladr`* in `ppp`-hypercolumn.

```{r}
#| message: false
(mdist = out$phenotype.nncross |> unlist() |> max())
out |> 
  aggregate_kerndens(by = ~ patient_id, from = 0, to = mdist)
```

# Appendix

We cover some minor and/or experimental features in the appendix, in order not to interrupt the main narrative of this vignette.

## On Trapezoidal Integration

### Average Vertical Height {#sec-vtrapz}

The [trapezoidal integration](https://en.wikipedia.org/wiki/Trapezoidal_rule) [blah blah (copy some English from Wikipedia)]{style="background-color: #FFFF00"}. Let $\{x_k; k=0,\cdots,N\}$ be a partition of the real interval $[a,b]$ such that $a = x_0 < x_1 < \cdots < x_{N-1} < x_N = b$ and $\Delta x_k= x_k - x_{k-1}$ be the length of the $k$-th sub-interval, then the trapezoidal approximation of the integration $$
\begin{split}
\int_a^b f(x)\,dx & \approx \sum_{k=1}^{N}{\dfrac{f(x_{k-1})+f(x_{k})}{2}}\Delta x_{k} \\
& = \left(\frac{f(x_0)}{2}+\sum _{k=1}^{N-1}f(x_{k})+\frac{f(x_N)}{2}\right)\Delta x, \quad\iff\ \forall k, \Delta x_{k}\equiv \Delta x
\end{split}
$$ {#eq-trapz}

We define the *average vertical height* of a trapezoidal integration as (@eq-trapz) divided by $N\Delta x=b-a$, the length of $x$-domain,

$$
\dfrac{\displaystyle\int_{a}^{b}f(x)\,dx}{b-a}\approx N^{-1}\left(\frac{f(x_0)}{2}+\sum _{k=1}^{N-1}f(x_{k})+\frac{f(x_N)}{2}\right)
$$ {#eq-vtrapz}

We illustrate the average vertical height (@eq-vtrapz) of a trapezoidal integration using a toy example with $(x_0,x_1,x_2,x_3,x_4,x_5)^t$ and $\{y_k = f(x_k);k=0,1,\cdots,5\}$ below.

```{r}
(x = seq.int(from = 10L, to = 20L, by = 2L))
set.seed(12); (y = rnorm(n = length(x), mean = 1, sd = .2))
```

Function `pracma::trapz()` calculates a trapezoidal integration (@eq-trapz).

```{r}
pracma::trapz(x, y)
```

Function `vtrapz()` calculates the average vertical height of a trapezoidal integration (@eq-vtrapz). The (tentative) prefix `v` indicates "vertical". The shaded rectangle in @fig-vtrapz has the same area as the trapezoidal integration. Therefore, we define the vertical height of the shaded rectangle as the *average vertical height* of the trapezoidal integration.

```{r}
vtrapz(x, y)
```

In R nomenclature, the term "cumulative" indicates an inclusive [scan](https://en.wikipedia.org/wiki/Prefix_sum#Scan_higher_order_function), that

> The `i`th element of the output is the operation result of the first-`i`-elements of the input


Function `pracma::cumtrapz()` calculates a cumulative trapezoidal integration. Note that the first element of the output is always `0`, as a trapezoidal integration needs at least $\left(x_0, f(x_0)\right)$ and $\left(x_1, f(x_1)\right)$.

```{r}
pracma::cumtrapz(x, y)
```

Function `cumvtrapz()` calculates the cumulative average vertical height of a trapezoidal integration. The output has,

-   the 1st element `NaN`, i.e., the result of `0` (trapzoidal integration) divided by `0` (length of $x$-domain).
-   the 2nd element $(f(x_0)+f(x_1))/2$
-   the $(i+1)$-th element $i^{-1}(f(x_0)/2+\sum_{k=1}^{i-1}f(x_k)+f(x_i)/2)$. Note that the R does *not* use [zero-based numbering](https://en.wikipedia.org/wiki/Zero-based_numbering); i.e., R `vector` indices start at `1L` instead of `0L`
-   the $(N+1)$-th and last element as (@eq-vtrapz)

```{r}
cumvtrapz(x, y)
```

@fig-vtrapz illustrates the concept of (cumulative) average vertical height of a trapezoidal integration using our toy example. <!--[Say some English as a summary statement.]{style="background-color: #FFFF00"}-->

```{r}
#| label: fig-vtrapz
#| code-fold: true
#| code-summary: "R code to illustrate (cumulative) average vertical height of trapezoidal integration"  
#| fig-height: 4
#| fig-align: left
#| fig-cap: "(Cumulative) average vertical height of trapezoidal integration"
visualize_vtrapz(x, y) + 
  ggplot2::theme_minimal()
```

## On `groupedHyperframe`

### Nested Grouping Structure {#sec-nestedGroup}

Interaction terms using colon operator `:` are allowed in the grouping structure, such as `g1/g2a:g2b/g3a:g3b:g3c`. This feature is made possible because the colon operator `:` has higher priority than the forward slash `/` in R `formula`.

```{r}
#| code-fold: true
#| code-summary: "Colon operator `:` has higher priority than forward slash `/`"
quote(g1/g2a:g2b/g3a:g3b:g3c) |>
  as.list()
```

Function `get_nested()` breaks down a nested grouping structure by the forward slash `/`.

```{r}
quote(g1/g2/g3) |>
  get_nested()
```

```{r}
quote(g1/g2a:g2b/g3a:g3b:g3c) |>
  get_nested()
```

The (nested) grouping structure `attr(., 'group')` of a `groupedHyperframe`

-   must denote the highest level using a `symbol` (e.g., `g1`)
-   may denote the lower levels using a `symbol` (e.g., `g2`) or an interaction-term (e.g., `g2a:g2b`)

## On `hyperframe` {#sec-hyperframe}

### `S3` methods in package **`spatstat.geom`**

Several `S3` method dispatches to `hyperframe` class in package **`spatstat.geom`** behave *very differently* from their counterpart in vanilla R. Users are strongly advised to read the documentation of these functions from package **`spatstat.geom`**.

| Generic Function | Method Dispatch to `data.frame` | Method Dispatch to `hyperframe` |
|------------------------|------------------------|------------------------|
| [`` base::`[` ``](https://search.r-project.org/R/refmans/base/html/Extract.html) | [`` base::`[.data.frame` ``](https://search.r-project.org/R/refmans/base/html/Extract.data.frame.html) | [`` spatstat.geom::`[.hyperframe` ``](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/Extract.hyperframe.html) |
| [`` base::`$<-` ``](https://search.r-project.org/R/refmans/base/html/Extract.html) | [`` base::`$<-.data.frame` ``](https://search.r-project.org/R/refmans/base/html/Extract.data.frame.html) | [`` spatstat.geom::`$<-.hyperframe` ``](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/Extract.hyperframe.html) |
| [`base::subset`](https://search.r-project.org/R/refmans/base/html/subset.html) | [`base::subset.data.frame`](https://search.r-project.org/R/refmans/base/html/subset.html) | [`spatstat.geom::subset.hyperframe`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/subset.hyperframe.html) |
| [`base::with`](https://search.r-project.org/R/refmans/base/html/with.html) | [`base::with.default`](https://search.r-project.org/R/refmans/base/html/with.html) | [`spatstat.geom::with.hyperframe`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/with.hyperframe.html) |
| [`base::within`](https://search.r-project.org/R/refmans/base/html/with.html) | [`base::within.data.frame`](https://search.r-project.org/R/refmans/base/html/with.html) | do not exist (as of v`r packageVersion('spatstat.geom')`) |

: `S3` methods `*.hyperframe()` that are drastically different from `*.data.frame()` or `*.default()`

### Superimpose multiple `hyperframe`s

The S3 method dispatch `superimpose.hyperframe()`, which does not exist in package **`spatstat.geom`** as of v`r packageVersion('spatstat.geom')`, superimposes multiple `hyperframe`s if-and-only-if they have `identical`

-   `dim`ensions, i.e., `spatstat.geom::dim.hyperframe()`
-   columns, i.e., `unclass(.)$df`
-   `names` and `class` of the `hypercolumn`s, i.e., `unclass(.)$hypercolumns`

The S3 method dispatch `superimpose.groupedHyperframe()` superimposes multiple `groupedHyperframe`s if-and-only-if they satisfy the *additional* criteria that they have `identical`

-   grouping structures, i.e., `attr(., 'group')`

We use a subset of the data set *`flu`* from package **`spatstat.data`** to illustrate the superimpose of `hyperframe`s.

```{r}
#| label: fluM
fluM = spatstat.data::flu |>
  spatstat.geom::subset.hyperframe(subset = (stain == 'M2-M1') & (virustype == 'wt'))
```

```{r}
#| code-fold: true
#| code-summary: The `hyperframe` *`fluM`*
fluM
```

The `hyperframe` *`fluM`* contains `r nrow(fluM)` subjects, each of them has a `ppp.object` with 200-500 points.

```{r}
#| code-fold: true
#| code-summary: Number of *`M1`* and/or *`M2`* points per `ppp.object` in hypercolumn *`fluM$pattern`*
fluM$pattern |>
  sapply(FUN = spatstat.geom::npoints)
fluM$pattern |>
  sapply(FUN = \(i) {
    i |> 
      spatstat.geom::marks.ppp() |> 
      table()
  }) |>
  addmargins()
```

We create a `hyperframe` *`fluM1`* which consists of the same columns as *`fluM`*, but a `ppp`-hypercolumn *`pattern`* with *`M1`* marks only. Similarly, we create another `hyperframe` *`fluM2`* which consists of the *`M2`* marks only. Note that as of package **`spatstat.geom`** v`r packageVersion('spatstat.geom')`, the tedious code below is the only way to insure that we do **not** use the row names of hyperframe as the element-names of the hypercolumns. In other words, we use `unclass()` to avoid invoking the `S3` method dispatch `` spatstat.geom::`$.hyperframe` ``. The `S3` method dispatch `` spatstat.geom::`$<-.hyperframe` `` is fine in this application.

```{r}
#| code-fold: false
#| code-summary: Some tedious code to create *`fluM1`* and *`fluM2`*
fluM1 = fluM2 = fluM
fluM1$pattern = unclass(fluM)$hypercolumns$pattern |> 
  spatstat.geom::solapply(FUN = spatstat.geom::subset.ppp, subset = (marks == 'M1'))
fluM2$pattern = unclass(fluM)$hypercolumns$pattern |> 
  spatstat.geom::solapply(FUN = spatstat.geom::subset.ppp, subset = (marks == 'M2'))
```

```{r}
#| code-fold: true
#| code-summary: Number of *`M1`* points per `ppp.object` in hypercolumn *`fluM1$pattern`*
fluM1$pattern |>
  sapply(FUN = spatstat.geom::npoints)
```

```{r}
#| code-fold: true
#| code-summary: Number of *`M2`* points per `ppp.object` in hypercolumn *`fluM2$pattern`*
fluM2$pattern |>
  sapply(FUN = spatstat.geom::npoints)
```

User may recreate the `hyperframe` *`fluM`* by combining the `hyperframe`s *`fluM2`* and *`fluM1`* using the `S3` method dispatch `superimpose.hyperframe()`. Note that the order of *`fluM2`*-then-*`fluM1`* matters, because the points are arranged in *`M2`*-then-*`M1`* in the original hypercolumn *`fluM$pattern`*.

```{r}
fluS = superimpose.hyperframe(fluM2, fluM1)
stopifnot(identical(fluS, fluM))
```

## On `fv.object`

### "Black solid curve" {#sec-blackSolidCurve}

The `S3` method dispatch `spatstat.explore::plot.fv()` visualizes the function values stored in an `fv.object` as a black-solid-curve.

```{r}
#| code-fold: true
#| code-summary: "Figure suppressed to reduce vignette file size"
#| fig-show: hide
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  plot()
```

Function `key1.fv()`, named after the code snippet `key[lty == 1L & col == 1L]`, finds the "name" of the function values in an `fv.object`. Function `key1.fv()` is a "psuedo" `S3` method dispatch, i.e., named in the fashion of `<generic>.<class>`, because we do not have an `S3` generic function `key1()` defined (as of package **`groupedHyperframe`** v`r packageVersion('groupedHyperframe')`).

```{r}
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  key1.fv()
```

Function `key1val.fv()` finds the function values in an `fv.object`, with the corresponding $r$-values as the `vector` `names`. Function `key1val.fv()` is also a "psuedo" `S3` method dispatch, because we do not have an `S3` generic function `key1val()` defined (as of package **`groupedHyperframe`** v`r packageVersion('groupedHyperframe')`).

```{r}
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  key1val.fv() |>
  head(n = 3L)
```

Functions `trapz.fv()` and `cumtrapz.fv()` calculate the (cumulative) trapezoidal integration under the black-solid-curve, with the help of functions `pracma::trapz()` and `pracma::cumtrapz()`. Both functions `trapz.fv()` and `cumtrapz.fv()` are "psuedo" `S3` method dispatches, as the workhorse functions in package **`pracma`** (as of v`r packageVersion('pracma')`) are not `S3` generic functions.

```{r}
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  trapz.fv()
```

```{r}
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  cumtrapz.fv() |>
  tail(n = 3L)
```

### Legal $r_\text{max}$ {#sec-legal_rmax}

In package **`spatstat.explore`** (up to v`r packageVersion('spatstat.explore')`), function `markcorr()` is the workhorse inside functions `Emark()`, `Vmark()` and `markvario()`. Function `markcorr()` relies on the un-exported workhorse function `spatstat.explore:::sewsmod()`, whose default `method = "density"` contains the calculation of the ratio of two kernel densities. Due to the floating-point precision of R, such density ratios may have exceptional/illegal returns of

-   `0`, from $0/\delta$, where $\delta\geq$ (approximately) `2.6e-324`
-   `NaN`, from $0/\varepsilon$, where $\varepsilon\leq$ (approximately) `2.5e-324`
-   `Inf`, from $\delta/0$, where $\delta\geq$ (approximately) `2.6e-324`

```{r}
#| code-fold: true
#| code-summary: "See for yourself"
0 / c(2.6e-324, 2.5e-324)
c(2.5e-324, 2.6e-324) / 0
```

Function `markcorr()` provides a default argument of parameter $r$ (see Appendix @sec-default_rmax), at which the mark correlation function $k_f(r)$ are evaluated. The S3 method dispatch `spatstat.explore::print.fv()` prints the *recommended range* and *available range* of the argument $r$.

```{r}
#| code-fold: true
#| code-summary: "Function spatstat.explore::print.fv() output"
spatstat.data::spruces |> 
  spatstat.explore::markcorr()
```

We may observe exceptional/illegal returns if we go beyond the recommended and/or available range. In the following example, we see that the mark correlation $k_f(r)$ (column *`iso`*) having exceptional/illegal values `0`, `NaN` and `Inf`.

```{r}
#| code-fold: true
#| code-summary: "Exceptions when parameter `r` out-of-range"
fv = spatstat.data::spruces |> 
  spatstat.explore::markcorr(r = 0:100)
fv |>
  spatstat.explore::as.data.frame.fv() |>
  utils::tail(n = 30L)
```

Function `lastLegal()` provides the *index* of the last legal function value in an `fv.object`.

```{r}
fv |>
  key1val.fv() |>
  lastLegal()
```

## On `ppp.object`

In this appendix section, we discuss a couple methods applicable to the `ppp.object`.

### Default $r_\text{max}$ {#sec-default_rmax}

The `S3` generic function `rmax_()` provides the default $r_\text{max}$ used in package **`spatstat.explore`** functions that returns an `fv.object`. The primary `S3` method dispatch `rmax_.ppp()` is an off-label use of the un-documented functions `spatstat.explore::rmax.rule()` and `spatstat.geom::handle.r.b.args()`.

| Function in package **`spatstat.explore`** | Call of `spatstat.explore::rmax.rule` | Default $r_\text{max}$ via `rmax_()` |
|------------------------|------------------------|------------------------|
| [`Emark` and `Vmark`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Emark.html), [`markcorr`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/markcorr.html), [`markvario`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/markvario.html) | `rmax.rule(fun = 'K', ...)` | `rmax_(fun = 'K')` |
| [`Kcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Kcross.html) , workhorse `Kest` and `Kmulti` | `rmax.rule(fun = 'K', ...)` | `rmax_(fun = 'K')` or `rmax_(fun = 'K', i, j)` |
| [`Gcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Gcross.html), workhorse `Gest` and `Gmulti` | `rmax.rule(fun = 'G', ...)` | `rmax_(fun = 'G')` or `rmax_(fun = 'G', i, j)` |
| [`Jcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Jcross.html), workhorse `Jest` and `Jmulti` | `rmax.rule(fun = 'J', ...)` | `rmax_(fun = 'J')` or `rmax_(fun = 'J', i, j)` |

: Default $r_\text{max}$ from functions in package **`spatstat.explore`** that return an `fv.object`

We demonstrate the use of `S3` method dispatch `rmax_.ppp()` using examples from package **`spatstat.data`**.

```{r}
#| code-fold: true
#| code-summary: "numeric-mark, rectangle-window, for function markcorr()"
spatstat.data::anemones |> rmax_(fun = 'K')
```

```{r}
#| code-fold: true
#| code-summary: "multitype-mark, rectangle-window, for function Gcross()"
spatstat.data::amacrine |> rmax_(fun = 'G')
spatstat.data::amacrine |> rmax_(fun = 'G', i = 'on', j = 'off')
spatstat.data::amacrine |> rmax_(fun = 'G', i = 'off', j = 'on')
```

```{r}
#| code-fold: true
#| code-summary: "multitype-mark, rectangle-window, for function Jcross()"
spatstat.data::paracou |> rmax_(fun = 'J')
spatstat.data::paracou |> rmax_(fun = 'J', i = 'adult', j = 'juvenile')
spatstat.data::paracou |> rmax_(fun = 'J', i = 'juvenile', j = 'adult')
```

Together with the additional `S3` method dispatches `rmax_.ppplist()` and `rmax_.hyperframe()`, user may obtain the default $r_\text{max}$ *before* applying the (potentially) very slow batch processes.

-   For functions `Emark_()`, `Vmark_()`, `markcorr_()`, and `markvario_()`,

```{r}
#| code-fold: false
#| code-summary: "fun = 'K', numeric (and multitype) mark"
s |> rmax_(fun = 'K')
```

-   For function `Kcross_()`,

```{r}
#| code-fold: false
#| code-summary: "fun = 'K', multitype mark"
s |> rmax_(fun = 'K')
s |> rmax_(fun = 'K', i = 'CK+.CD8-', j = 'CK-.CD8+')
s |> rmax_(fun = 'K', i = 'CK-.CD8+', j = 'CK+.CD8-')
```

-   For function `Gcross_()`,

```{r}
#| code-fold: false
#| code-summary: "fun = 'G', multitype mark"
s |> rmax_(fun = 'G')
s |> rmax_(fun = 'G', i = 'CK+.CD8-', j = 'CK-.CD8+')
s |> rmax_(fun = 'G', i = 'CK-.CD8+', j = 'CK+.CD8-')
```

-   For function `Jcross_()`,

```{r}
#| code-fold: false
#| code-summary: "fun = 'J', multitype"
s |> rmax_(fun = 'J')
s |> rmax_(fun = 'J', i = 'CK+.CD8-', j = 'CK-.CD8+')
s |> rmax_(fun = 'J', i = 'CK-.CD8+', j = 'CK+.CD8-')
```

### $k$-Means Clustering

The `S3` generic `.kmeans()` performs $k$-means clustering. We name this generic function with a prefix `.` because the workhorse function `stats::kmeans()` is not an `S3` generic. The `S3` generic `.kmeans()` returns an object of class `'kmeans'` as defined in R package **`stats`**. Currently only one `S3` method dispatch `.kmeans.ppp()` is planned.

The `S3` method dispatch `.kmeans.ppp()` has parameters

-   `formula`, $x$- and/or $y$- coordinate(s) and/or (one of the) numeric `marks`
-   (optional) `centers`, number of clusters
-   (optional) `clusterSize`, "expected" cluster size.

User should specify one of the two optional parameters `centers` and `clusterSize`. If both are specified, then parameter `clusterSize` takes priority and parameter `centers` is ignored.

Data set *`bei`* from package **`spatstat.data`** has $x$- and $y$-coordinates only, i.e., no `marks`.

```{r}
spatstat.data::bei
```

```{r}
#| code-fold: true
#| code-summary: 'Cluster *`bei`* by `~ x`'
spatstat.data::bei |> 
  .kmeans(formula = ~ x, centers = 3L)
```

```{r}
#| code-fold: true
#| code-summary: 'Cluster *`bei`* by `~ x + y`'
spatstat.data::bei |> 
  .kmeans(formula = ~ x + y, centers = 3L)
```

```{r}
#| code-fold: true
#| code-summary: 'Cluster *`bei`* by `~ x + y`, using parameter `clusterSize`'
spatstat.data::bei |> 
  .kmeans(formula = ~ x + y, clusterSize = 1000L)
```

Data set *`waka`* from package **`spatstat.data`** has `numeric` `marks` stored in `'vector'`-format.

```{r}
spatstat.data::waka
```

```{r}
#| code-fold: true
#| code-summary: 'Cluster *`waka`* by `~ x + marks`'
spatstat.data::waka |> 
  .kmeans(formula = ~ x + marks, centers = 3L)
```

```{r}
#| code-fold: true
#| code-summary: 'Cluster *`waka`* by `~ x + y + marks`'
spatstat.data::waka |> 
  .kmeans(formula = ~ x + y + marks, centers = 3L)
```

Data set *`shapley`* from package **`spatstat.data`** has three (3) `numeric` `marks` stored in `'dataframe'`-format.

```{r}
spatstat.data::shapley
```

```{r}
#| code-fold: true
#| code-summary: 'Cluster *`shapley`* by `~ x + y + Mag`'
spatstat.data::shapley |> 
  .kmeans(formula = ~ x + y + Mag, centers = 3L)
```

```{r}
#| code-fold: true
#| code-summary: 'Cluster *`shapley`* by `~ x + Mag`'
spatstat.data::shapley |> 
  .kmeans(formula = ~ x + Mag, centers = 3L)
```

#### Split by $k$-Means Clustering

The `S3` generic function `split_kmeans()` splits `ppp.object`, `ppplist`, and `hyperframe` by $k$-means clustering. We use a subset of the data set *`flu`* from package **`spatstat.data`** to illustrate the various `S3` method dispatches of `split_kmeans()`.

```{r}
<<fluM>>
```

```{r}
#| code-fold: true
#| code-summary: The `hyperframe` *`fluM`*
fluM
```

The `S3` method dispatch `split_kmeans.default()` splits a `ppp.object` by $k$-means clustering.

```{r}
#| code-fold: true
#| code-summary: 'Split `ppp.object` by $k$-means clustering'
fluM$pattern[[1L]] |> 
  split_kmeans(formula = ~ x + y, centers = 3L)
```

The `S3` method dispatch `split_kmeans.listof()` splits a `ppplist`, i.e., a `listof` `ppp.object`s by $k$-means clustering. The returned object has `attributes`

-   `attr(.,'.id')`, indices of the `ppp.object`s before splitting.
-   `attr(.,'.cluster')`, indices of $k$-means clusters, nested in `.id`.

```{r}
#| code-fold: true
#| code-summary: 'Split `ppplist` by $k$-means clustering'
fluM$pattern |> 
  split_kmeans(formula = ~ x + y, centers = 3L) 
```

The `S3` method dispatch `split_kmeans.hyperframe()` splits a `hyperframe` and/or `groupedHyperframe` by $k$-means clustering of the *one-and-only-one* `ppp`-hypercolumn. The returned object is a `groupedHyperframe` with grouping structure

-   `~.id/.cluster`, if the input is a `hyperframe`
-   `~ <existing/grouping/structure>/.cluster`, if the input is a `groupedHyperframe`. Note that the grouping level `.id` is **believed** to be equivalent to *the lowest level of existing grouping structure*.

```{r}
#| code-fold: true
#| code-summary: 'Split `hyperframe` by $k$-means clustering of the one-and-only-one `ppp`-hypercolumn'
fluM |> 
  split_kmeans(formula = ~ x + y, centers = 3L)
```

### Pairwise Tj√∏stheim's Coefficient

The `S3` generic `pairwise_cor_spatial()` calculates the nonparametric, rank-based, Tj√∏stheim's correlation coefficients [@Tjostheim78; @Hubert82] in a pairwise-combination fashion, using the workhorse function `SpatialPack::cor.spatial()`. All `S3` method dispatches return a object of class `'pairwise_cor_spatial'`, which `inherits` from class `'dist'`.

The `S3` method dispatch `pairwise_cor_spatial.ppp()` finds the nonparametric Tj√∏stheim's correlation coefficients from the pairwise-combinations of all numeric marks of a `ppp.object`.

```{r}
(r = spatstat.data::finpines |> pairwise_cor_spatial())
```

The printing of `'pairwise_cor_spatial'` is taken care of by function `stats:::print.dist()`.

The `S3` method dispatch `as.matrix.pairwise_cor_spatial()` returns a `matrix` of pairwise Tj√∏stheim's coefficient with `diag`onal values of 1. Note that this matrix is ***not*** a `cor`relation matrix, because Tj√∏stheim's correlation coefficient

-   is nonparametric, i.e., there is no definition of the corresponding `cov`ariance, standard deviation `sd`, nor the conversion `cov2cor` method;
-   does not provide a mathematical mechanism to ensure this matrix is [positive definite](https://en.wikipedia.org/wiki/Definite_matrix).

```{r}
r |> as.matrix()
```

```{=html}
<!--
# Appendix B: On `fv.object`

In this appendix section, we discuss a couple methods applicable to the `fv.object`.
-->
```

### `r '\U1f6a7'` Global Envelope Test

`r '\U1f6a7'` This section is under construction.

## What We Don't Do

Lastly, we keep note of the features that we plan **not** to support in package **`groupedHyperframe`**. Those features are technically tedious to implement, and/or have relatively easy workaround.

### `S4` method dispatch `merge`

The authors plan [**not**]{style="background-color: #FFFF00"} to implement an `S4` method dispatch `merge` (e.g., `S3` method dispatch `base::merge.data.frame()`) for `hyperframe` and/or `groupedHyperframe` classes, for the obstacles explained below.

-   There is not an `S3` method dispatch `merge.hyperframe` in package **`spatstat.geom`** (as of v`r packageVersion('spatstat.geom')`);
-   Should the authors decide to implement `setMethod(f = merge, ...)` for `hyperframe` class, at least two (2) `S4` method dispatches need to be written for
    -   `signature = c(x = 'hyperframe', y = 'data.frame')`
    -   `signature = c(x = 'hyperframe', y = 'hyperframe')`, for which the authors need to define a `match` mechanism for hypercolumns.
-   Should the authors decide to implement `setMethod(f = merge, ...)` for `groupedHyperframe` class, at least three (3) `S4` method dispatches need to be written for
    -   `signature = c(x = 'groupedHyperframe', y = 'data.frame')`
    -   `signature = c(x = 'groupedHyperframe', y = 'hyperframe')`, similar as above;
    -   `signature = c(x = 'groupedHyperframe', y = 'groupedHyperframe')`, for which the authors need to consider the (potentially different) grouping structures of `x` and `y` inputs.

The authors suggest users do `base::merge.data.frame()` first, then do `as.groupedHyperframe()` as a workaround.

## Terms & Abbreviations {#sec-terms}

### in Math

| Symbol | [LaTeX](https://www.latex-project.org) Source | Description | Example |
|------------------|------------------|------------------|------------------|
| $\equiv$ | `$\equiv$` | Equivalent to | $x\equiv a$ says "variable $x$ is equivalent to constant $a$" |
| $\forall$ | `$\forall$` | For all | $\forall k$ says "for all $k$" |
| $\iff$ | `$\iff$` | If-and-only-if | $A\iff B$ says "$A$ is true, if and only if $B$ is true" |

### in R

| Term / Abbreviation | Description |
|------------------------------------|------------------------------------|
| CRAN, R | The Comprehensive R Archive Network, <https://cran.r-project.org> |
| `Depends`, `Imports`, `Suggests`, `Enhances` | [*Writing R Extensions*, Section 1.1.3 *Package Dependencies*](https://cran.r-project.org/doc/manuals/r-devel/R-exts.html#Package-Dependencies) |
| [`|>`](https://search.r-project.org/R/refmans/base/html/pipeOp.html) | Forward pipe operator introduced since R version 4.1.0 |
| [`:`](https://search.r-project.org/R/refmans/base/html/Colon.html) | Colon operator for [`interaction`](https://search.r-project.org/R/refmans/base/html/interaction.html) of [`factor`](https://search.r-project.org/R/refmans/base/html/factor.html)s, see section *Details* of [`formula`](https://search.r-project.org/R/refmans/stats/html/formula.html) documentation |
| `/` | Forward slash operator for nested grouping structure, see section *Details* of [`formula`](https://search.r-project.org/R/refmans/stats/html/formula.html) documentation |
| [`::`](https://search.r-project.org/R/refmans/base/html/ns-dblcolon.html) | Explicitly-[namespace](https://search.r-project.org/R/refmans/base/html/ns-reflect.html)d function or object |
| [`attr`](https://search.r-project.org/R/refmans/base/html/attr.html), [`attributes`](https://search.r-project.org/R/refmans/base/html/attributes.html) | Attributes |
| [`cor`, `cov`, `cov2cor`](https://search.r-project.org/R/refmans/stats/html/cor.html) | Correlation matrix, variance-covariance matrix, and their conversion |
| [`cor.spatial`](https://search.r-project.org/CRAN/refmans/SpatialPack/html/cor.spatial.html) | Tj√∏stheim's nonparametric correlation coefficient, from package **`SpatialPack`** [@SpatialPack] |
| [`data.frame`](https://search.r-project.org/R/refmans/base/html/data.frame.html) | Data frame |
| [`diag`](https://search.r-project.org/R/refmans/base/html/diag.html) | Matrix diagonals |
| [`dist`](https://search.r-project.org/R/refmans/stats/html/dist.html) | Distance matrix; to take advantage of `stats:::as.matrix.dist` |
| [`factor`](https://search.r-project.org/R/refmans/base/html/factor.html) | Categorical object, a.k.a., factor |
| [`file.size`](https://search.r-project.org/R/refmans/base/html/file.info.html) | File size in bytes |
| (one-sided) [`formula`](https://search.r-project.org/R/refmans/stats/html/formula.html) | Formula, or [one-sided formula](https://search.r-project.org/R/refmans/stats/html/asOneSidedFormula.html) |
| [`fv`, `fv.object`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/fv.object.html), [`plot.fv`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/plot.fv.html) | (Plot of) function value table, from package **`spatstat.explore`** |
| [`groupedHyperframe`](https://CRAN.R-project.org/package=groupedHyperframe) | Grouped hyper data frame |
| `hypercolumns`, [`hyperframe`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/hyperframe.html) | (Hyper columns of) hyper data frame, from package **`spatstat.geom`** |
| [`identical`](https://search.r-project.org/R/refmans/base/html/identical.html) | Exact equality in R |
| [`im`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/im.html) | Pixel image object, from package **`spatstat.geom`** |
| [`inherits`](https://search.r-project.org/R/refmans/base/html/class.html) | Class inheritance |
| [`Inf`](https://search.r-project.org/R/refmans/base/html/is.finite.html) | Positive infinity $\infty$ |
| `kerndens` | Kernel [`density`](https://search.r-project.org/R/refmans/stats/html/density.html), `stats::density.default()$y` |
| [`kmeans`](https://search.r-project.org/R/refmans/stats/html/kmeans.html) | $k$-means clustering [@kmeans] |
| [`language`](https://search.r-project.org/R/refmans/base/html/is.language.html) | R language object |
| [`list`](https://search.r-project.org/R/refmans/base/html/list.html), [`listof`](https://search.r-project.org/R/refmans/stats/html/listof.html) | Lists of objects |
| [`.Machine`](https://search.r-project.org/R/refmans/base/html/zMachine.html) | Numerical characteristics of the machine R is running on, e.g., 32-bit integers and IEC 60559 floating-point (double precision) arithmetic |
| [`markformat`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/spatstat.geom-internal.html) | Storage mode of `marks`, from package **`spatstat.geom`** |
| [`marks`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/spatstat.geom-internal.html), [`is.marked`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/is.marked.html) | Marks of a point pattern, from package **`spatstat.geom`** |
| [`match`](https://search.r-project.org/R/refmans/base/html/match.html) | Value matching |
| [`merge`](https://search.r-project.org/R/refmans/base/html/merge.html) | Merge two `data.frame`s |
| [`mc.cores`](https://search.r-project.org/R/refmans/parallel/html/mclapply.html) | Number of central processing unit (CPU) cores to use for parallel computing |
| [`message`](https://search.r-project.org/R/refmans/base/html/message.html) | Diagnostic message printed in R console |
| [`multitype`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/spatstat.geom-internal.html) | Multitype spatial object, from package **`spatstat.geom`** |
| [`NaN`](https://search.r-project.org/R/refmans/base/html/is.finite.html) | Not-a-Number |
| [`names`](https://search.r-project.org/R/refmans/base/html/names.html) | Names of an R object |
| [`npoints`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/npoints.html) | Number of points in a point pattern, from package **`spatstat.geom`** |
| [`object.size`](https://search.r-project.org/R/refmans/utils/html/object.size.html) | Memory allocation |
| `pmean`, `pmedian` | Point-wise mean and median, from package `groupedHyperframe` |
| [`pmax`, `pmin`](https://search.r-project.org/R/refmans/base/html/Extremes.html) | Point-wise maxima and minima |
| [`ppp`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/ppp.html), [`ppp.object`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/ppp.object.html) | (Marked) point pattern, from package **`spatstat.geom`** |
| [`quantile`](https://search.r-project.org/R/refmans/stats/html/quantile.html) | Quantile |
| `S3`, `generic`, [`methods`](https://search.r-project.org/R/refmans/utils/html/methods.html) | `S3` object oriented system, [`UseMethod`](https://search.r-project.org/R/refmans/base/html/UseMethod.html); [`getS3method`](https://search.r-project.org/R/refmans/utils/html/getS3method.html); <https://adv-r.hadley.nz/s3.html> |
| `S4`, `generic`, `methods` | `S4` object oriented system, [`isS4`](https://search.r-project.org/R/refmans/base/html/isS4.html); [`setClass`](https://search.r-project.org/R/refmans/methods/html/setClass.html); [`setMethod`](https://search.r-project.org/R/refmans/methods/html/setMethod.html); [`getMethod`](https://search.r-project.org/R/refmans/methods/html/getMethod.html); <https://adv-r.hadley.nz/s4.html> |
| [`save`](https://search.r-project.org/R/refmans/base/html/save.html), [`saveRDS`](https://search.r-project.org/R/refmans/base/html/readRDS.html), `xz` | Save with [`xz`](https://en.wikipedia.org/wiki/XZ_Utils) compression |
| [`sd`](https://search.r-project.org/R/refmans/stats/html/sd.html) | Standard deviation |
| [`search`](https://search.r-project.org/R/refmans/base/html/search.html) | Search path |
| [`split`](https://search.r-project.org/R/refmans/base/html/split.html) | Divide into groups |
| [`stopifnot`](https://search.r-project.org/R/refmans/base/html/stopifnot.html) | To ensure the truth of R [`expression`](https://search.r-project.org/R/refmans/base/html/expression.html)s |
| [`Surv`](https://search.r-project.org/CRAN/refmans/survival/html/Surv.html) | Survival, i.e., time-to-event, object, from package **`survival`** [@survival] |
| [`symbol`, `name`](https://search.r-project.org/R/refmans/base/html/name.html) | R object name/symbol |
| [`tempfile`](https://search.r-project.org/R/refmans/base/html/tempfile.html) | Create names for temporary files |
| [`trapz`, `cumtrapz`](https://search.r-project.org/CRAN/refmans/pracma/html/trapz.html) | (Cumulative) [trapezoidal integration](https://en.wikipedia.org/wiki/Trapezoidal_rule), from package **`pracma`** [@pracma] |
| [`unclass`](https://search.r-project.org/R/refmans/base/html/class.html) | Remove `S3` `'class'` attribute |
| [`vector`](https://search.r-project.org/R/refmans/base/html/vector.html) | Vector |

# References

::: {#refs}
:::
