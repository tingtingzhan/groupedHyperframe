---
title: "Grouped Hyper Data Frame"
author: Tingting Zhan
date: today
format: 
  html:
    page-layout: full
    html-math-method: katex
number-sections: true
toc: true
toc-location: left
toc-depth: 4
toc-title: ''
editor: source
bibliography: groupedHyperframe.bib
knitr:
  opts_chunk: 
    collapse: true
    comment: "#" 
vignette: >
  %\VignetteIndexEntry{intro}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

```{=html}
<!--
`r knitr::asis_output('\U1f5dd')`
seems not needed
-->
```

# Introduction

This vignette of R package **`groupedHyperframe`** ([CRAN](https://cran.r-project.org/package=groupedHyperframe), [Github](https://github.com/tingtingzhan/groupedHyperframe), [RPubs](https://rpubs.com/tingtingzhan/groupedHyperframe)) documents

-   the creation of `groupedHyperframe` object,
-   the batch processes for a `hyperframe` and/or `groupedHyperframe`, and
-   the aggregation of various statistics over (nested) grouping structure.

R terminology might be different from that of mathematics and statistics. Please refer to @sec-Rterms for explanation and reference of the terms and abbreviations used in this vignette.

## Prerequisite

### Environment

Package **`groupedHyperframe`** requires R version 4.5.0 (released 2025-04-11) or higher ([macOS](https://cran.r-project.org/bin/macosx/), [Windows](https://cran.r-project.org/bin/windows/base/), [Linux](https://cran.r-project.org/bin/linux/)).

An Integrated Development Environment (IDE), e.g., [RStudio](https://posit.co/download/rstudio-desktop/) [@RStudio] or [Positron](https://positron.posit.co/download.html), is not required, but highly recommended.

This vignette is created under `r R.version$version.string` using packages **`knitr`** [@knitr, v`r packageVersion('knitr')`], **`quarto`** [@quarto, v`r packageVersion('quarto')` with [Quarto](https://quarto.org/docs/get-started/) v`r quarto::quarto_version()`] and **`rmarkdown`** [@rmarkdown, v`r packageVersion('rmarkdown')`]. Package documentation is facilitated using package **`roxygen2`** [@roxygen2, v`r packageVersion('roxygen2')`]

```{r}
#| code-fold: true
#| code-summary: "Environment on author's computer"
#| label: author-env
Sys.info()[c('sysname', 'release', 'machine')]
R.version
```

### Dependency

Package **`groupedHyperframe`** `Enhances` the **`spatstat.*`** family of packages [@spatstat15; @spatstat05], specifically

-   **`spatstat.explore`** (dev v`r packageVersion('spatstat.explore')`), with
    -   new methods for `fv.object`
    -   batch processes to return a hypercolumn of `fv.object`s
-   **`spatstat.geom`** (dev v`r packageVersion('spatstat.geom')`), with
    -   a new derived class of `hyperframe`
    -   new methods for `ppp.object` and `hyperframe`

Package **`groupedHyperframe`** `Imports` packages

-   **`cli`** [@cli, v`r packageVersion('cli')`], for attractive command line interfaces
-   `r '\U1f5dd'` **`GET`** [@GET, v`r packageVersion('GET')`], key dependency, for global envelope test
-   **`ggplot2`** [@ggplot2, v`r packageVersion('ggplot2')`], **`geomtextpath`** [@geomtextpath, v`r packageVersion('geomtextpath')`], **`scales`** [@scales, v`r packageVersion('scales')`] for educational visualization
-   `r '\U1f5dd'` **`matrixStats`** [@matrixStats, v`r packageVersion('matrixStats')`], key dependency, for matrix arithmetic
-   **`parallel`** shipped with vanilla `r R.version$version.string`, for parallel computing
-   `r '\U1f5dd'` **`pracma`** [@pracma, v`r packageVersion('pracma')`], key dependency, for (cumulative) trapezoidal integration
-   `r '\U1f5dd'` **`SpatialPack`** [@SpatialPack, v`r packageVersion('SpatialPack')`], key dependency, for TjÃ¸stheim's coefficient of spatial association
-   `r '\U1f5dd'` **`spatstat.explore`** (dev v`r packageVersion('spatstat.explore')`), **`spatstat.geom`** (dev v`r packageVersion('spatstat.geom')`), **`spatstat.random`** (dev v`r packageVersion('spatstat.random')`), key dependency, for spatial statistics

Package **`groupedHyperframe`** `Suggests` packages

-   **`patchwork`** [@patchwork v`r packageVersion('patchwork')`], for collage of `ggplot`s
-   **`rpart`** [@rpart v`r packageVersion('rpart')`], required by function `spatstat.explore::rocEngine()` as of package **`spatstat.explore`** dev v`r packageVersion('spatstat.explore')`.
-   `r '\U1f5dd'` **`spatstat.data`** (dev v`r packageVersion('spatstat.data')`), key suggest, for example spatial data set
-   `r '\U1f5dd'` **`survival`** [@survival, v`r packageVersion('survival')`], key suggest (@sec-start-library).

### **`spatstat.*`** Family

Package **`groupedHyperframe`** requires the development versions of the **`spatstat.*`** family of packages.

```{r}
#| eval: false
remotes::install_github('spatstat/spatstat', upgrade = 'always')
remotes::install_github('spatstat/spatstat.data', upgrade = 'always')
remotes::install_github('spatstat/spatstat.explore', upgrade = 'always')
remotes::install_github('spatstat/spatstat.geom', upgrade = 'always')
remotes::install_github('spatstat/spatstat.linnet', upgrade = 'always')
remotes::install_github('spatstat/spatstat.model', upgrade = 'always')
remotes::install_github('spatstat/spatstat.random', upgrade = 'always')
remotes::install_github('spatstat/spatstat.sparse', upgrade = 'always')
remotes::install_github('spatstat/spatstat.univar', upgrade = 'always')
remotes::install_github('spatstat/spatstat.utils', upgrade = 'always')
```

```{r}
#| label: dev_spatstat
#| eval: true
#| code-fold: true
#| code-summary: 'Developer version of **`spatstat.*`** family ahead of CRAN'
spatstat = c(
  'spatstat', 'spatstat.data', 'spatstat.explore', 'spatstat.geom', 'spatstat.linnet', 
  'spatstat.model', 'spatstat.random', 'spatstat.sparse', 'spatstat.univar', 'spatstat.utils'
)
cran = available.packages(contriburl = 'https://cran.rstudio.com/src/contrib') |> 
  as.data.frame.matrix() |>
  subset.data.frame(subset = Package %in% spatstat, select = c('Package', 'Version')) |> 
  within.data.frame(expr = {
    `on CRAN` = Version; Version = NULL
  })
github = installed.packages() |>
  as.data.frame.matrix() |>
  subset.data.frame(subset = Package %in% spatstat, select = c('Package', 'Version')) |> 
  within.data.frame(expr = {
    `on GitHub` = Version; Version = NULL
  })
merge.data.frame(cran, github, by = 'Package') |> 
  subset.data.frame(subset = `on CRAN` != `on GitHub`) |>
  within.data.frame(expr = {
    Package = Package |> sprintf(fmt = '**`%s`**')
  }) |>
  knitr::kable(
    row.names = FALSE,
    # label = 'tbl-dev_spatstat', # no use!
    caption = Sys.Date() |> format() |> 
      sprintf(fmt = 'Developer version of `spatstat.*` family ahead of CRAN, as of %s')
  )
```

### Package **`groupedHyperframe`**

Experimental (and maybe unstable) features of package **`groupedHyperframe`** are released *extremely frequently* to [Github](https://github.com/tingtingzhan/groupedHyperframe). [Active developers should use the Github version; suggestions and bug reports are welcome!]{style="background-color: #FFFF00"} Stable releases to [CRAN](https://CRAN.R-project.org/package=groupedHyperframe) are typically updated every 2 to 3 months, or when the authors have an upcoming manuscript in the peer-reviewing process.

```{r}
#| eval: false
remotes::install_github('tingtingzhan/groupedHyperframe')
```

```{r}
#| eval: false
#| code-fold: true
#| code-summary: "Developers, do NOT use the CRAN version!"
utils::install.packages('groupedHyperframe') # Developers, do NOT use!!
```

## Getting Started {#sec-start}

Examples in the main text of this vignette, i.e., excluding those in the Appendix, require that the `search` path has

```{r}
#| message: false
#| label: search
library(groupedHyperframe)
library(survival)
```

### Use of `library()` {#sec-start-library}

In this vignette, the authors try their best to avoid using `library()`, in order to keep the user's `search` path as clean as possible. The authors use explicitly `namespace`d function calls, e.g., `pracma::trapz()` instead of `library(pracma); trapz()`, so that the users always know from which package a function is defined.

The only places where the authors (have to) use `library()` are

<details>

<summary>`library(groupedHyperframe)` in @sec-start</summary>

To indicate that this is a vignette of package **`groupedHyperframe`**.

</details>

<details>

<summary>`library(survival)` in @sec-start</summary>

To put the un-`export`ed `S3` method dispatch `survival:::as.data.frame.Surv()` on the `search` path. This is necessary, so that the function `spatstat.geom::hyperframe()` could recognize a `Surv`-column instead of treating it as a `matrix`-`hypercolumn`.

</details>

<details>

<summary>`library(patchwork)` in Appendix @sec-vtrapz</summary>

To put the un-`export`ed `S3` method dispatch `patchwork:::ggplot_add.ggplot()` on the `search` path. This is necessary, so that the `S3` generic function `ggplot2::ggplot_add()` could dispatch correctly when needed.

</details>

<details>

<summary>`library(spatstat.geom)` and `library(spatstat.explore)` in Appendix @sec-ppp, @sec-fv and @sec-hyperframe.</summary>

These are necessary, so that the function `utils::methods()` could recognize `from` which package the `S3` method dispatches are defined.

</details>

### Use of `S3` Method Dispatch & Namespace

In this vignette, for education of junior statisticians, the authors try their best to call the `S3` method dispatches

<details>

<summary>explicitly without namespace, if they are `export`ed from package **`base`**, **`stats`**, **`utils`**, etc.</summary>

e.g., the authors use `within.data.frame()` instead of

-   `within()` or
-   `base::within()` or
-   `base::within.data.frame()`

Obviously, it is impractical to use *`` `[.data.frame`(swiss, 'Fertility') ``* instead of *`swiss[, 'Fertility']`* or *`swiss$Fertility`* in R code-chunks. The audience is expected to be reasonably comfortable with the use of the `S3` generic functions `` base::`$` `` and `` base::`[` ``. The authors do not explicitly mention the `S3` method dispatch `` base::`[.data.frame`() `` unless required by the context.

</details>

<details>

<summary>by their generic functions without namespace, if they are un-`export`ed from package **`base`**, **`stats`**, **`utils`**, etc.</summary>

e.g., the authors use `head()` instead of

-   `utils::head()` or
-   `utils:::head.default()`

</details>

<details>

<summary>explicitly with namespace, no matter they are `export`ed or un-`export`ed from [`contrib`uted packages](https://cran.r-project.org/web/packages)</summary>

e.g., the authors use `spatstat.geom::with.hyperframe()` instead of

-   `library(spatstat.geom); with.hyperframe()`, or
-   `library(spatstat.geom); with()`.

e.g., the authors use `spatstat.geom::print.ppp()` instead of

-   `library(spatstat.geom); print.ppp()`, or
-   `library(spatstat.geom); print()`, or
-   `library(spatstat.geom); (.)`

e.g., the authors use `patchwork:::ggplot_add.ggplot()`.

Obviously, it is impractical to use *`` spatstat.geom::`$.hyperframe`(flu, 'pattern') ``* instead of *`flu$pattern`* in R code-chunks. The audience is expected to be reasonably comfortable with the use of the `S3` generic function `` base::`$` ``. The authors will explicitly mention the `S3` method dispatch `` spatstat.geom::`$.hyperframe`() `` in surrounding text to emphasize a different behavior from vanilla `r R.version.string`.

</details>

<details>

<summary>in package **`groupedHyperframe`** by their generic functions without namespace</summary>

e.g., the authors use `library(groupedHyperframe)` in @sec-start and `log()` in R code-chunks in the body of the vignette, instead of

-   `library(groupedHyperframe); log.ppp()` or
-   `groupedHyperframe::log.ppp()`.

All `S3` method dispatches defined in package **`groupedHyperframe`** are `export`ed.

</details>

Data sets are always called with its namespace.

<details>

<summary>data from package **`datasets`** shipped with vanilla `r R.version.string`</summary>

e.g., the authors use *`datasets::penguins`* instead of

-   *`penguins`* or
-   *`data('penguins', package = 'datasets')`*

</details>

<details>

<summary>data from [`contrib`uted packages](https://cran.r-project.org/web/packages)</summary>

e.g., the authors use *`spatstat.data::amacrine`* instead of

-   *`library(spatstat.data); amacrine`* or
-   *`data('amacrine', package = 'spatstat.data')`*

</details>

<details>

<summary>data from package **`groupedHyperframe`**</summary>

e.g., the authors use `library(groupedHyperframe)` in @sec-start and *`Ki67`* in R code-chunks in the body of the vignette, instead of

-   *`groupedHyperframe::Ki67`* or
-   *`data('Ki67', package = 'groupedHyperframe')`*

</details>

```{r}
#| echo: false
#| label: cran
op = par(no.readonly = TRUE)
#options(mc.cores = 1L) # for CRAN submission
```

## Peer-Reviewed Publications

Package **`groupedHyperframe`** plays a pivotal role in these peer reviewed publications from the authors.

### @Zhan25

> `r citation(package = 'hyper.gam')[[1L]] |> format(style = 'text') |> gsub(pattern = '\n', replacement = ' ', x = _)`

<details>

<summary>[BibTeX](https://ctan.org/pkg/bibtex) and/or [BibLaTeX](https://ctan.org/pkg/biblatex) entries for [LaTeX](https://www.latex-project.org) users</summary>

```{r}
#| echo: false
#| comment: ''
c(
  citation(package = 'hyper.gam'),
  citation(package = 'groupedHyperframe')
) |> toBibtex()
```

</details>

as well as @Yi25; @Yi23a; @Yi23b, was featured with a non-spatial `hyperframe` *`Ki67q`* with a numeric-hypercolumn *`logKi67.quantile`*. Functions in the code-chunk below are explained in @sec-groupedHyperframe.

```{r}
Ki67q = groupedHyperframe::Ki67 |>
  within.data.frame(expr = {
    x = y = NULL # remove x- and y-coords for non-spacial application
  }) |>
  as.groupedHyperframe(group = ~ patientID/tissueID) |> 
  aggregate_quantile(by = ~ patientID, probs = seq.int(from = .01, to = .99, by = .01))
```

```{r}
#| message: false
#| code-fold: true
#| code-summary: 'A `hyperframe` object *`Ki67q`*: aggregated quantiles'
Ki67q |>
  head()
```

Readers are encouraged to learn more about this application from package **`hyper.gam`** vignette ([RPubs](https://rpubs.com/tingtingzhan/hyper_gam), [CRAN](https://CRAN.R-project.org/package=hyper.gam/vignettes/applications.html)), section *Quantile Index*.

{{< pagebreak >}}

## Acknowledgement

This work is supported by National Institutes of Health, U.S. Department of Health and Human Services grants

-   R01CA222847 ([I. Chervoneva](https://orcid.org/0000-0002-9104-4505), [T. Zhan](https://orcid.org/0000-0001-9971-4844), and [H. Rui](https://orcid.org/0000-0002-8778-261X))
-   R01CA253977 (H. Rui and I. Chervoneva).

{{< pagebreak >}}

# Grouped Hyper Data Frame {#sec-groupedHyperframe}

An `S3` class `hyperframe`, for **hyper data frame**, is defined in package **`spatstat.geom`**. A `hyperframe` contains columns either as `vector`s like in a `data.frame`, or as `list`s of objects of the same class, a.k.a., the `hypercolumns`. The `hyperframe` data structure is particularly useful in spatial analysis, e.g., with medical images, where the spatial information in each image would be represented by one element in a hypercolumn. For example, example data *`demohyper`* from package **`spatstat.data`** contains a `factor` column *`Group`*, a point-pattern `ppp`-hypercolumn *`Points`*, and a pixel image `im`-hypercolumn *`Image`*. Several `S3` method dispatches to the `hyperframe` class behave *very differently* from their counterpart in vanilla R (Appendix @sec-hyperframe).

```{r}
spatstat.data::demohyper
```

The authors introduce a new `S3` class `groupedHyperframe`, for **grouped hyper data frame**, which `inherits` from the `hyperframe` class. The derived class `groupedHyperframe` has additional `attributes`

-   `attr(.,'group')`, a one-sided `formula` of the (nested) grouping structure, e.g., *`~patient/image`* when each patient has one or more images. Appendix @sec-nestedGroup provides references to the grammar of the nested grouping structure $g_1/.../g_m$ (`~g1/.../gm`).

The `S3` generic function `as.groupedHyperframe()` converts objects of various classes into a `groupedHyperframe`.

The authors have a toy data example *`wrobel_lung`* in package **`groupedHyperframe`** originally from Dr. [Julia Wrobel](https://sph.emory.edu/profile/faculty/julia-wrobel). Consider a subset *`wrobel_lung0`* with the only non-identical column *`hladr`* in the lowest group *`image_id`* of the nested grouping structure *`~patient_id/image_id`*.

```{r}
#| label: wrobel_lung0
wrobel_lung0 = wrobel_lung |>
  within.data.frame(expr = {
    x = y = NULL
    dapi = phenotype = tissue = NULL
    stage_numeric = pack_years = adjuvant_therapy = NULL # to save console space
  })
```

```{r}
#| code-fold: true
#| code-summary: 'A `data.frame` object *`wrobel_lung0`*'
wrobel_lung0 |> 
  head()
```

The `S3` method dispatch `as.groupedHyperframe.data.frame()` converts a `data.frame`, e.g., *`wrobel_lung0`*, with substantial amount of duplicated information into a `groupedHyperframe`. This function

1.  inspects the input `data.frame` by the user-specified (nested) `group`ing structure, e.g., *`~patient_id/image_id`*;
2.  identifies the `data.frame` column(s), e.g., the numeric column *`wrobel_lung0$hladr`*, with *non-identical elements* within the lowest group, and converts them into the hypercolumn(s) of the output `groupedHyperframe`, e.g., *`wrobel_lung0g$hladr`*. Each row of a `groupedHyperframe` represents the lowest group of the nested grouping structure.

```{r}
#| label: wrobel_lung0g
wrobel_lung0g = wrobel_lung0 |> 
  as.groupedHyperframe(group = ~ patient_id/image_id)
```

Another `S3` method dispatch `as.groupedHyperframe.hyperframe()` is discussed in Appendix @sec-asgroupedHyperframe-hyperframe.

The `S3` method dispatch `print.groupedHyperframe()` highlights the nested grouping structure, number of clusters at each grouping level, as well as the first 10 (or less) rows of the input.

```{r}
wrobel_lung0g
```

Converting a `data.frame` with substantial amount of duplicated information into a `groupedHyperframe` greatly reduces the memory allocation. A `groupedHyperframe`, however, would not reduce much the `save`d `file.size` compared to a `data.frame`, if `xz` compression is used for both.

```{r}
#| code-fold: true
#| code-summary: "Reducing memory allocation"
#| label: object-size
unclass(object.size(wrobel_lung0g) / object.size(wrobel_lung0))
```

```{r}
#| code-fold: true
#| code-summary: "Not reducing `xz`-compressed file size"
#| label: xz
f_g = tempfile(fileext = '.rds')
wrobel_lung0g |> saveRDS(file = f_g, compress = 'xz')
f = tempfile(fileext = '.rds')
wrobel_lung0 |> saveRDS(file = f, compress = 'xz')
file.size(f_g) / file.size(f)
```

Functions `aggregate_*()` aggregates the hypercolumns in a `groupedHyperframe` at either one of the nested grouping levels $g_1,\cdots,g_{m-1}$. Aggregation at the lowest grouping level $g_m$ is ignored, i.e., no aggregation to be performed. Available aggregation methods are the point-wise minima `base::pmin()`, maxima `base::pmax()`, means `pmean()` (default) and medians `pmedian()`.

Function `aggregate_quantile()` aggregates the `quantile`s of each element in the numeric-hypercolumn, e.g., *`hladr`* in *`wrobel_lung0g`*, by point-wise means (default of parameter `f_aggr_`) at the biologically independent group, e.g., *`~patient_id`*. The returned object is a `hyperframe` instead of a `groupedHyperframe`, as we have *one* aggregated *`hladr.quantile`* per *`~patient_id`*, thus eliminates the need for a grouping structure. The R console output is taken care of by the `S3` method dispatch `spatstat.geom::print.hyperframe()`.

```{r}
#| message: false
wrobel_lung0g |>
  aggregate_quantile(by = ~ patient_id, probs = seq.int(from = .01, to = .99, by = .01))
```

{{< pagebreak >}}

# Grouping `ppp`-Hypercolumn {#sec-grouped_ppp}

In this section, the authors first introduce the creation of a `groupedHyperframe` with *one-and-only-one* point pattern (`ppp`) hypercolumn. Then, the authors discuss

-   the batch processes of spatial point pattern analyses on the *one-and-only-one* `ppp`-hypercolumn of a `hyperframe` (and/or `groupedHyperframe`). These batch processes are not intended for a `hyperframe` (and/or `groupedHyperframe`) with multiple `ppp`-hypercolumns in the foreseeable future, as that would require checking for name clashes in the `marks` from multiple `ppp`-hypercolumns.
-   the aggregation of batch-process-returns over the nested grouping structure.

Function `grouped_ppp()` creates a `groupedHyperframe` with *one-and-only-one* `ppp`-hypercolumn. In the following example, the argument `formula` takes form of `<marks> ~ <variable.of.interest> | <group>`, specifically,

-   the point pattern `marks`, e.g., a numeric mark *`hladr`* and a `multitype` mark *`phenotype`*, on the left-hand-side
-   the additional predictors and/or endpoints for downstream analysis, e.g., *`OS`*, *`gender`* and *`age`*, before the `|` separator on the right-hand-side. Alternatively, user may use the dot symbol `.` to denote the remaining variables except for those mentioned in the `marks` and the nested grouping structure.
-   the (nested) grouping structure, e.g., *`image_id`* nested in *`patient_id`*, after the `|` separator on the right-hand-side.

```{r}
s = wrobel_lung |>
   grouped_ppp(formula = hladr + phenotype ~ OS + gender + age | patient_id/image_id)
```

```{r}
#| code-fold: true
#| code-summary: Alternatively, use dot symbol `.` for additional predictors and/or endpoints
wrobel_lung |>
   grouped_ppp(formula = hladr + phenotype ~ . | patient_id/image_id)
```

The `S3` method dispatch `print.groupedHyperframe()` highlights the nested grouping structure, number of clusters at each grouping level, as well as the first 10 (or less) rows of the `groupedHyperframe`.

```{r}
s
```

## Batch processes {#sec-batch}

@tbl-batch-numeric-fv and @tbl-batch-multitype-fv present the batch processes that return a function value table (`fv`) hypercolumn, i.e., a `listof` `fv.object`s (Appendix @sec-fvlist).

| Batch Process | Workhorse Function in Package **`spatstat.explore`** | `fv`-hypercolumns Suffix |
|:-----------------------|:-----------------------|:-----------------------|
| `Emark_()` and `Vmark_()` | [`Emark` and `Vmark`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Emark.html), conditional mean $E(r)$ and variance $V(r)$, diagnostics for dependence between the points and the marks [@Emark] | `.E` and `.V` |
| `markcorr_()` | [`markcorr`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/markcorr.html), marked correlation $k_{mm}(r)$ or generalized mark correlation $k_f(r)$ [@markcorr] | `.k` |
| `markvario_()` | [`markvario`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/markvario.html), mark variogram $\gamma(r)$ [@markvario] | `.gamma` |
| `Kmark_()` | [`Kmark`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Kmark.html), mark-weighted $K_f(r)$ function [@Kmark] | `.K` |

: Batch processes; numeric `marks` to `fv`-hypercolumn {#tbl-batch-numeric-fv}

| Batch Process | Workhorse Function in Package **`spatstat.explore`** | `fv`-hypercolumns Suffix |
|:-----------------------|:-----------------------|:-----------------------|
| `Gcross_()` | [`Gcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Gcross.html), multitype nearest-neighbour distance $G_{ij}(r)$ | `.G` |
| `Kcross_()` | [`Kcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Kcross.html), multitype $K_{ij}(r)$ | `.K` |
| `Jcross_()` | [`Jcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Jcross.html), multitype $J_{ij}(r)$ [@Jcross] | `.J` |
| `Lcross_()` | [`Lcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Lcross.html), multitype $L_{ij}(r)=\sqrt{\frac{K_{ij}(r)}{\pi}}$ | `.L` |
| `markconnect_()` | [`markconnect`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/markconnect.html), multitype $p_{ij}(r)$ | `.p` |

: Batch processes; `multitype` `marks` to `fv`-hypercolumn {#tbl-batch-multitype-fv}

@tbl-batch-multitype-numeric presents the batch processes that return a numeric hypercolumn, i.e., a hypercolumn which consists of a `list` of numeric `vector`s.

| Batch Process | Workhorse Function in Package **`spatstat.geom`** | numeric-hypercolumns Suffix |
|:-----------------------|:-----------------------|:-----------------------|
| `nncross_()` | [`nncross.ppp`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/nncross.html)`(., what = 'dist')`, nearest neighbour distance | `.nncross` |

: Batch processes; `multitype` `marks` to numeric-hypercolumn {#tbl-batch-multitype-numeric}

Multiple batch processes may be applied to a `hyperframe` (and/or `groupedHyperframe`) in a pipeline using the native pipe operator `|>` introduced since R version 4.1.0.

```{r}
r = seq.int(from = 0, to = 250, by = 10)
out = s |>
  Emark_(r = r, correction = 'none') |> # slow
  # Vmark_(r = r, correction = 'none') |> # slow
  # markcorr_(r = r, correction = 'none') |> # slow
  # markvario_(r = r, correction = 'none') |> # slow
  # Kmark_(r = r, correction = 'none') |> # fast
  Gcross_(i = 'CK+.CD8-', j = 'CK-.CD8+', r = r, correction = 'none') |> # fast
  # Kcross_(i = 'CK+.CD8-', j = 'CK-.CD8+', r = r, correction = 'none') |> # fast
  nncross_(i = 'CK+.CD8-', j = 'CK-.CD8+', correction = 'none') # fast
```

The `message` of "Legal $r_\text{max}$" is explained in detail in Appendix @sec-fvlist.

The returned `hyperframe` (and/or `groupedHyperframe`) has

-   `fv`-hypercolumn *`hladr.E`*, created by function `Emark_()` on the numeric mark *`hladr`*
-   `fv`-hypercolumn *`phenotype.G`*, created by function `Gcross_()` on the `multitype` mark *`phenotype`*
-   numeric-hypercolumn *`phenotype.nncross`*, created by function `nncross_()` on the `multitype` mark *`phenotype`*

```{r}
out
```

## Truncated Aggregation {#sec-aggregate}

In this section, the authors discuss the aggregation over nested grouping structure.

### Of `fv`-hypercolumn(s)

Function `aggregate_fv()` performs (truncated) aggregation of

-   *`<mark>.<fv>.y`*, the *function values*, i.e., the black-solid-curve (Appendix @sec-blackSolidCurve) determined by function `spatstat.explore::plot.fv()`
-   *`<mark>.<fv>.cumtrapz`*, the *cumulative trapezoidal integration* (Appendix @sec-trapz) under the black-solid-curve
-   *`<mark>.<fv>.cumvtrapz`*, the *cumulative average vertical height of trapezoidal integration* (Appendix @sec-vtrapz) under the black-solid-curve

When a user-specified $r$-`vector` is provided to a batch process (@sec-batch) on *all* `ppp.object`s in the `ppp`-hypercolumn, inevitably some of the `fv`-returns may contain exceptional/illegal function values (Appendix @sec-legal_rmax). In this case, the aggregation is *truncated* at the minimum legal $r_\text{max}$ of the `fv.object`s in each `fv`-hypercolumn.

In the following example, the returned object *`afv`* has

-   numeric-hypercolumns *`hladr.E.y`*, *`hladr.E.cumtrapz`* and *`hladr.E.cumvtrapz`* from `fv`-hypercolumns *`hladr.E`*. Function values from all `fv.object`s in the `fv`-hypercolumns *`hladr.E`* are legal, therefore, this aggregation is not truncated.
-   numeric-hypercolumns *`phenotype.G.y`*, *`phenotype.G.cumtrapz`* and *`phenotype.G.cumvtrapz`* from `fv`-hypercolumns *`phenotype.G`*. This aggregation is *truncated* at the minimum legal $r_\text{max}=240$ of the `fv.object`s in the `fv`-hypercolumn *`phenotype.G`*.

```{r}
(afv = out |>
  aggregate_fv(by = ~ patient_id, f_aggr_ = pmean))
```

User may specify an $r_\text{max}$ for truncation using the argument `rmax` of the workhorse function `summary.fvlist()` (Appendix @sec-fvlist) of function `aggregate_fv()`.

```{r}
#| results: hide
out |>
  aggregate_fv(by = ~ patient_id, f_aggr_ = pmean, rmax = 220)
```

If the user-specified $r_\text{max}$ `rmax` is greater than the minimum legal $r_\text{max}$ (Appendix @sec-legal_rmax), the user's $r_\text{max}$ `rmax` will be ignored.

```{r}
#| results: hide
out |>
  aggregate_fv(by = ~ patient_id, f_aggr_ = pmean, rmax = 260)
```

In `hyperframe` *`afv`*, each one of the numeric-hypercolumns contains tabulated values on the common grid of the $r$-`vector`. One "slice" of the hypercolumn *`hladr.E.cumvtrapz`* at $r=50$ may be extracted by calling the `S3` method dispatch `spatstat.geom::with.hyperframe()` (which behaves *very differently* from function `base::with.default()`, Appendix @sec-hyperframe),

```{r}
E_r50_a = afv |>
  spatstat.geom::with.hyperframe(expr = {
    hladr.E.cumvtrapz['50']
  })
E_r50_a
```

Alternatively, the 5th slice (which corresponds to $r=50$, as the cumulative trapzoidal integration starts at $r=10$ instead of $r=0$) of the hypercolumn *`hladr.E.cumvtrapz`* may be extracted by

```{r}
E_r50_b = afv |>
  spatstat.geom::with.hyperframe(expr = {
    hladr.E.cumvtrapz[5L]
  })
E_r50_b
stopifnot(identical(E_r50_a, E_r50_b))
```

Developers may use the `S3` method dispatch `t.vectorlist()` (Appendix @sec-vectorlist).

```{r}
tE = afv$hladr.E.cumvtrapz |>
  t.vectorlist()
stopifnot(identical(E_r50_a, tE[[5L]]))
```

### Of numeric-hypercolumn, and numeric marks in `ppp`-hypercolumn

#### On `quantile`s

Function `aggregate_quantile()` aggregates the `quantile`s

-   of the numeric-hypercolumns, and
-   of the numeric marks in the one-and-only-one `ppp`-hypercolumn (Appendix @sec-isnumeric-ppp).

In the following example, the returned object has

-   numeric-hypercolumn *`phenotype.nncross.quantile`*, the aggregated `quantile`s of numeric-hypercolumn *`phenotype.nncross`*.
-   numeric-hypercolumn *`hladr.quantile`*, the aggregated `quantile`s of the numeric mark *`hladr`* in `ppp`-hypercolumn.

```{r}
#| message: false
out |>
  aggregate_quantile(by = ~ patient_id, probs = seq.int(from = 0, to = 1, by = .1))
```

#### On kernel densities

Function `aggregate_kerndens()` aggregates the kernel density of the numeric-hypercolumns and the numeric marks in the `ppp`-hypercolumn.

In the following example, the returned object has

-   numeric-hypercolumn *`phenotype.nncross.kerndens`*, the aggregated kernel densities of numeric-hypercolumn *`phenotype.nncross`*.
-   numeric-hypercolumn *`hladr.kerndens`*, the aggregated kernel densities of the numeric mark *`hladr`* in `ppp`-hypercolumn.

```{r}
#| message: false
(mdist = out$phenotype.nncross |> unlist() |> max())
out |> 
  aggregate_kerndens(by = ~ patient_id, from = 0, to = mdist)
```

{{< pagebreak >}}

# Manuscript in Progress

## Paper 1

<details>

<summary>[BibTeX](https://ctan.org/pkg/bibtex) and/or [BibLaTeX](https://ctan.org/pkg/biblatex) entries for [LaTeX](https://www.latex-project.org) users</summary>

```{r}
#| echo: false
#| comment: ''
c(
  citation(package = 'groupedHyperframe')
) |> toBibtex()
```

</details>

The authors are working on a manuscript about the batch process (@sec-batch) and the truncated aggregation (@sec-aggregate, Appendix @sec-fvlist).

## Paper 2

The authors are working on a manuscript about the simulation of grouped hyper data frame.

Readers are encouraged to learn more about this application from package **`groupedHyperframe.random`** vignette ([RPubs](https://rpubs.com/tingtingzhan/groupedHyperframe_random), [CRAN](https://CRAN.R-project.org/package=groupedHyperframe.random/vignettes/intro.html)).

## Paper 3

The authors are working on a manuscript about predictor selection from a numeric-`hypercolumn`.

Readers are encouraged to learn more about this application from package **`maxEff`** vignette ([RPubs](https://rpubs.com/tingtingzhan/maxEff), [CRAN](https://CRAN.R-project.org/package=maxEff/vignettes/intro.html)).

# Appendix {#sec-appendix}

The Appendix presents technical details intended for readers with advanced expertise in the R programming language, including minor and/or experimental features, to avoid disrupting the focus and flow of the main narrative in this vignette. The audience is expected to

-   have a reasonably good understanding of the [`S3` object-oriented programming system of R](https://adv-r.hadley.nz/s3.html).
-   be familiar with the `S3` generic functions in vanilla `r R.version.string` packages **`base`**, **`stats`**, **`utils`**, etc.
-   be familiar with the `S3` generic functions in packages **`spatstat.geom`**, **`spatstat.explore`**, etc.

```{=html}
<!--
The Appendix is typically organized in the way that

-   the Markdown document **Header 2**, e.g. @sec-appendix `.0`, is about the object `class`;
-   the Markdown document **Header 3**, e.g. @sec-appendix `.0.0`, is about the method dispatches.
-->
```

For ease of navigation, all R code-chunks in the Appendix are folded. The R code-chunks are categorized by their purpose, e.g.,

-   **Data**, to create an R object for further operations.
-   **Review**, to demonstrate the use of functions shipped with vanilla `r R.version.string`, or from [`contrib`uted packages](https://cran.r-project.org/web/packages).
-   **Example**, to demonstrate the use of functions from package **`groupedHyperframe`**.
-   **Advanced**, discussions for R experts.
-   **Figure**, to create a `ggplot`.
-   **Workaround**, to provide alternative solutions to a problem.
-   **Future**, upcoming tasks of package **`groupedHyperframe`**.

Readers who wish to extend the package **`groupedHypeframe`** or incorporate it into their own methodology are strongly encouraged to study the Appendix thoroughly.

## On Trapezoidal Integration {#sec-trapz}

The [chained trapezoidal rule](https://en.wikipedia.org/wiki/Trapezoidal_rule) of approximating a definite integral is an ancient idea since the dawn of human civilization.

Let $\{x_k; k=0,\cdots,N\}$ be a partition of the real interval $[a,b]$ such that $a = x_0 < x_1 < \cdots < x_{N-1} < x_N = b$ and $\Delta x_k= x_k - x_{k-1}$ be the length of the $k$-th sub-interval, then the chained-trapezoidal approximation of the integration

$$
\begin{split}
\int_a^b f(x)\,dx & \approx \sum_{k=1}^{N}{\dfrac{f(x_{k-1})+f(x_{k})}{2}}\Delta x_{k} \\
& = \left(\frac{f(x_0)}{2}+\sum _{k=1}^{N-1}f(x_{k})+\frac{f(x_N)}{2}\right)\Delta x, \quad\iff\ \forall k, \Delta x_{k}\equiv \Delta x
\end{split}
$$ {#eq-trapz}

Consider

```{r}
#| code-fold: true
#| code-summary: '**Data**: a toy example *`x`* $=(x_0,x_1,x_2,x_3,x_4,x_5)^t$ and *`y`* $=\\{y_k = f(x_k);k=0,1,\cdots,5\\}$'
#| label: trapz_toy
x. = seq.int(from = 10L, to = 20L, by = 2L)
set.seed(23); (x = rnorm(n = length(x.), mean = x., sd = .5))
set.seed(12); (y = rnorm(n = length(x.), mean = 1, sd = .2))
```

Note that the authors intentionally make the toy example data *`x`* *not* equidistant, as neither the chained trapezoidal rule framework nor the function `pracma::trapz()` *requires* the equidistant assumption.

Function `pracma::trapz()` calculates a trapezoidal integration (@eq-trapz), visualized in @fig-vtrapz(A).

```{r}
#| code-fold: true
#| code-summary: '**Review**: function `pracma::trapz()`'
pracma::trapz(x, y)
```

In R nomenclature, the term "cumulative" indicates an inclusive [scan](https://en.wikipedia.org/wiki/Prefix_sum#Scan_higher_order_function), that

> The `i`th element of the output is the operation result of the first-`i`-elements of the input

Function `pracma::cumtrapz()` calculates a cumulative trapezoidal integration. Note that the first element of the output is always `0`, as a trapezoidal integration needs at least $\left(x_0, f(x_0)\right)$ and $\left(x_1, f(x_1)\right)$. The first `0`-value is often removed for downstream analysis, e.g. in Appendix @sec-summary_fvlist.

```{r}
#| code-fold: true
#| code-summary: '**Review**: function  `pracma::cumtrapz()`'
pracma::cumtrapz(x, y)
```

### Average Vertical Height {#sec-vtrapz}

The authors define the *average vertical height* of a trapezoidal integration as the chained-trapezoid (@eq-trapz) divided by the length of $x$-domain $b-a$,

$$
\begin{split}
(b-a)^{-1}\displaystyle\int_a^b f(x)\,dx & \approx (b-a)^{-1} \sum_{k=1}^{N}{\dfrac{f(x_{k-1})+f(x_{k})}{2}}\Delta x_{k} \\
& = N^{-1}\left(\frac{f(x_0)}{2}+\sum _{k=1}^{N-1}f(x_{k})+\frac{f(x_N)}{2}\right), \quad\iff\ \forall k, \Delta x_{k}\equiv \Delta x
\end{split}
$$ {#eq-vtrapz}

Function `vtrapz()` calculates the average vertical height of a trapezoidal integration (@eq-vtrapz). The (tentative) prefix `v` indicates "vertical". The shaded rectangle in @fig-vtrapz(A) has the same area as the trapezoidal integration. Therefore, the authors define the vertical height of the shaded rectangle as the *average vertical height* of the trapezoidal integration.

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `vtrapz()`'
vtrapz(x, y)
```

Function `cumvtrapz()` calculates the cumulative average vertical height of a trapezoidal integration. If $\forall k$, $\Delta x_{k}\equiv \Delta x$, the output has,

-   the 1st element `NaN`, i.e., the result of `0` (trapzoidal integration) divided by `0` (length of $x$-domain). The first `NaN`-value is often removed for downstream analysis, e.g. in Appendix @sec-summary_fvlist.
-   the 2nd element $(f(x_0)+f(x_1))/2$
-   the $(i+1)$-th element $i^{-1}(f(x_0)/2+\sum_{k=1}^{i-1}f(x_k)+f(x_i)/2)$. Note that the R does *not* use [zero-based numbering](https://en.wikipedia.org/wiki/Zero-based_numbering); i.e., R `vector` indices start at `1L` instead of `0L`
-   the $(N+1)$-th and last element as (@eq-vtrapz)

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `cumvtrapz()`'
cumvtrapz(x, y)
```

@fig-vtrapz visualizes the concept of (cumulative) average vertical height of a trapezoidal integration with

(A) the toy example of non-equidistant $(x_0,x_1,\cdots,x_5)^t$ and $(y_0,y_1,\cdots,y_5)^t$;
(B) the kernel `stats::density()`, using the elements `$x` and `$y`. Obviously, this practice is meaningless mathematically, as a density function has $x$-domain of $(-\infty, \infty)$, thus the average vertical height of the trapzoidal integration under a density curve should be zero. This practice is meaningful to an *empirical* density though, if we use the `range` of the actual observations as the $x$-domain.
(C) the empirical cumulative distribution function `stats::ecdf()`, using the objects `x` and `y` in the enclosing `environment`. Obviously, this practice is meaningless mathematically, as a distribution function has $x$-domain of $(-\infty, \infty)$, thus the average vertical height of the trapzoidal integration under a distribution curve should be zero. This practice is meaningful to an *empirical* distribution though, if we use the `range` of the actual observations as the $x$-domain.
(D) the conditional mean $E(r)$ between the points and the marks, from function `spatstat.explore::Emark()` (Appendix @sec-blackSolidCurve). [Say some English]{style="background-color: #FFFF00"}
(E) the conditional variance $V(r)$ between the points and the marks, from function `spatstat.explore::Vmark()` (Appendix @sec-blackSolidCurve). [Say some English]{style="background-color: #FFFF00"}
(F) the [receiver operating characteristic (ROC) curve](https://en.wikipedia.org/wiki/Receiver_operating_characteristic) of a `ppp.object`, from function `spatstat.explore::roc.ppp()` (Appendix @sec-blackSolidCurve). The average vertical height of the trapezoidal integration `vtrapz` under the ROC-curve, is *not* numerically `identical` to the area-under-ROC-curve (AU-ROC) via `spatstat.explore::auc.ppp()`. This is due to the fact that the workhorse function `spatstat.explore::spatialCDFframe()` of AU-ROC uses the interpolation via `stats::approxfun()` instead of the trapezoidal integration via `pracma::trapz()`, as of package **`spatstat.explore`** v`r packageVersion('spatstat.explore')`.

```{r}
#| code-fold: true
#| code-summary: "**Figure**: Panel (A), visualize `vtrapz` & `cumvtrapz` of a toy example"
fig_vtrapz_1 = visualize_vtrapz(x, y) + 
  ggplot2::labs(title = '(A). a toy example')
```

```{r}
#| code-fold: true
#| code-summary: "**Figure**: Panel (B), visualize `vtrapz` & `cumvtrapz` of `stats::density()`"  
set.seed(12); fig_vtrapz_2 = rnorm(n = 1e3L) |> density() |> visualize_vtrapz() + 
  ggplot2::labs(title = '(B). stats::density()')
```

```{r}
#| code-fold: true
#| code-summary: "**Figure**: Panel (C), visualize `vtrapz` & `cumvtrapz` of `stats::ecdf()`"  
set.seed(27); fig_vtrapz_3 = rnorm(n = 1e3L) |> ecdf() |> visualize_vtrapz() + 
  ggplot2::labs(title = '(C). stats::ecdf()')
```

```{r}
#| code-fold: true
#| code-summary: "**Figure**: Panel (D), visualize `cumvtrapz` of `spatstat.explore::Emark()`"  
fig_vtrapz_4 = spatstat.data::spruces |>
  spatstat.explore::Emark() |>
  visualize_vtrapz(draw.v = FALSE, draw.rect = FALSE) +
  ggplot2::labs(title = '(D). spatstat.explore::Emark()')
```

```{r}
#| code-fold: true
#| code-summary: "**Figure**: Panel (E), visualize `cumvtrapz` of `spatstat.explore::Vmark()`"  
fig_vtrapz_5 = spatstat.data::spruces |>
  spatstat.explore::Vmark() |>
  visualize_vtrapz(draw.v = FALSE, draw.rect = FALSE) +
  ggplot2::labs(title = '(E). spatstat.explore::Vmark()')
```

```{r}
#| code-fold: true
#| code-summary: "**Figure**: Panel (F), visualize `vtrapz` & `cumvtrapz` of `spatstat.explore::roc()`"
swedishpines_roc = spatstat.data::swedishpines |>
  spatstat.explore::roc.ppp(covariate = 'x')
swedishpines_roc |>
  vtrapz.fv()
spatstat.data::swedishpines |> 
  spatstat.explore::auc.ppp(covariate = 'x')
fig_vtrapz_6 = swedishpines_roc |> 
  visualize_vtrapz() + 
  ggplot2::labs(title = '(F). spatstat.explore::roc()')
```

```{r}
#| label: fig-vtrapz
#| warning: false
#| code-fold: true
#| code-summary: "**Figure**: Panels collaged, visualize `vtrapz` and `cumvtrapz`"  
#| fig-height: 7.5
#| fig-width: 10
#| fig-align: left
#| fig-cap: "(Cumulative) average vertical height of trapezoidal integration"
library(patchwork)
(fig_vtrapz_1 + fig_vtrapz_2 + fig_vtrapz_3 + fig_vtrapz_4 + fig_vtrapz_5 + fig_vtrapz_6 +
  plot_layout(ncol = 2L)) & 
  ggplot2::theme_minimal()
```

## On `ppp.object` {#sec-ppp}

Function `spatstat.geom::ppp()` returns a `ppp.object`, i.e., an object with `S3` class `'ppp'`. In addition to

```{r}
#| message: false
#| code-fold: true
#| code-summary: 'The `S3` method dispatches to `ppp.object` defined in package **`spatstat.geom`**'
library(spatstat.geom)
methods(class = 'ppp') |> 
  attr(which = 'info', exact = TRUE) |>
  subset.data.frame(subset = from == 'spatstat.geom') |>
  within.data.frame(expr = {
    visible = NULL
  })
```

```{r}
#| message: false
#| code-fold: true
#| code-summary: 'The `S3` method dispatches to `ppp.object` defined in package **`spatstat.explore`**'
library(spatstat.explore)
methods(class = 'ppp') |> 
  attr(which = 'info', exact = TRUE) |>
  subset.data.frame(subset = from == 'spatstat.explore') |>
  within.data.frame(expr = {
    visible = NULL
  })
```

Package **`groupedHyperframe`** implements the additional `S3` method dispatches in @tbl-S3_ppp,

```{r}
#| code-fold: true
#| code-summary: 'Additional `S3` method dispatches to `ppp.object`'
#| label: tbl-S3_ppp
S3_ppp = methods(class = 'ppp') |> 
  attr(which = 'info', exact = TRUE) |>
  subset.data.frame(subset = from == 'groupedHyperframe') |>
  within.data.frame(expr = {
    generic = generic |> sprintf(fmt = '`%s`')
  })
rownames(S3_ppp) = rownames(S3_ppp) |> 
  sprintf(fmt = '`%s`')
S3_ppp |> 
  knitr::kable(
    # label = 'tbl-S3_ppp', # no use!
    caption = '`S3` method dispatches to class `\'ppp\'`'
  )
```

The authors have [**not**]{style="background-color: #FFFF00"} implemented

-   the `S3` method dispatches of `na.fail()` and `na.pass()` to a `ppp.object` (Appendix @sec-dont-na-ppp).

### Are `marks` `numeric`? {#sec-isnumeric-ppp}

The `S3` method dispatch `is.numeric.ppp()` determines whether the `marks`, if any, in a `ppp.object` are `numeric`.

```{r}
#| code-fold: true
#| code-summary: "**Example**: function `is.numeric.ppp()` on `'none'`-`markformat`"
spatstat.data::cells
spatstat.data::cells |>
  is.numeric()
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: function `is.numeric.ppp()` on `'vector'`-`markformat`"
spatstat.data::longleaf
spatstat.data::longleaf |>
  is.numeric()
spatstat.data::urkiola
spatstat.data::urkiola |>
  is.numeric()
```

Note that the `S3` method dispatches `is.numeric.ppp()` and `spatstat.geom::is.multitype.ppp()` behave differently for `'dataframe'`-`markformat`.

```{r}
#| code-fold: true
#| code-summary: "**Review** & **Example**: functions `is.numeric.ppp()` vs. `spatstat.geom::is.multitype.ppp()` on `'dataframe'`-`markformat`"
spatstat.data::betacells
spatstat.data::betacells |>
  spatstat.geom::is.multitype.ppp()
spatstat.data::betacells |>
  is.numeric()
```

### Log of `numeric` `marks`

The `S3` method dispatches

-   `log.ppp()` and `log1p.ppp()` perform `log`- and $\log(x+1)$-transformation, respectively,
-   `log2.ppp()` and `log10.ppp()` performs base-`2` and base-`10` `log`-transformations, respectively,

on one or more numeric `marks` of a `ppp.object`.

```{r}
#| code-fold: true
#| code-summary: "**Example**: `log`-transformations on `'none'`-`markformat`"
spatstat.data::cells
cells_log = spatstat.data::cells |>
  log()
cells_log1p = spatstat.data::cells |>
  log1p()
cells_log2 = spatstat.data::cells |>
  log2()
cells_log10 = spatstat.data::cells |>
  log10()
stopifnot(
  identical(cells_log, spatstat.data::cells),
  identical(cells_log1p, spatstat.data::cells),
  identical(cells_log2, spatstat.data::cells),
  identical(cells_log10, spatstat.data::cells)
)
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: `log.ppp()` on numeric-`marks` in `'vector'`-`markformat`"
spatstat.data::longleaf
spatstat.data::longleaf |>
  spatstat.geom::marks.ppp() |>
  range()
spatstat.data::longleaf |> 
  log() |>
  spatstat.geom::marks.ppp() |>
  range()
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: `log1p.ppp()` on numeric-`marks` in `'vector'`-`markformat`"
spatstat.data::bronzefilter
spatstat.data::bronzefilter |>
  spatstat.geom::marks.ppp() |>
  range()
spatstat.data::bronzefilter |> 
  log() |>
  spatstat.geom::marks.ppp() |>
  range()
spatstat.data::bronzefilter |> 
  log1p() |>
  spatstat.geom::marks.ppp() |>
  range()
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: `log.ppp()` on numeric-`marks` in `'dataframe'`-`markformat`"
spatstat.data::betacells
spatstat.data::betacells |>
  spatstat.geom::marks.ppp() |>
  with.default(expr = area) |>
  range()
spatstat.data::betacells |> 
  log() |>
  spatstat.geom::marks.ppp() |>
  with.default(expr = area) |>
  range()
```

### Missing `marks` Handling {#sec-na-ppp}

The `S3` method dispatches `na.omit.ppp()` and `na.exclude.ppp()` `omit`s and `exclude`s, respectively, the missing `marks` from a `ppp.object`. Both functions return a `ppp.object`.

If missingness exists in the `marks`, the `'na.action'`-`attr`ibute of the `marks` is saved as an `attr`ibute of the returned `ppp.object`.

```{r}
#| code-fold: true
#| code-summary: "**Example**: functions `na.omit.ppp()` and  `na.exclude.ppp()` on `'none'`-`markformat`"
spatstat.data::cells
cells_omit = spatstat.data::cells |>
  na.omit()
cells_exclude = spatstat.data::cells |>
  na.exclude()
stopifnot(
  identical(cells_omit, spatstat.data::cells),
  identical(cells_exclude, spatstat.data::cells)
)
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: functions `na.omit.ppp()` and  `na.exclude.ppp()` on `'vector'`-`markformat`, no missingness"
spatstat.data::amacrine
amacrine_omit = spatstat.data::amacrine |>
  na.omit()
amacrine_exclude = spatstat.data::amacrine |>
  na.exclude()
stopifnot(
  identical(amacrine_omit, spatstat.data::amacrine),
  identical(amacrine_exclude, spatstat.data::amacrine)
)
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: functions `na.omit.ppp()` and  `na.exclude.ppp()` on `'dataframe'`-`markformat`"
nbfires. = spatstat.data::nbfires[1:100]
nbfires. |> 
  spatstat.geom::npoints.ppp()
nbfires_omit = nbfires. |> 
  na.omit() 
nbfires_exclude = nbfires. |> 
  na.exclude() 
nbfires_omit |> 
  spatstat.geom::npoints.ppp()
nbfires_omit |> 
  attr(which = 'na.action', exact = TRUE)
nbfires_exclude |> 
  attr(which = 'na.action', exact = TRUE)
```

### Extract via `[`

In an email to the authors, [Prof. Adrian Baddeley](https://en.wikipedia.org/wiki/Adrian_Baddeley) [@spatstat05] has kindly explained that in the package **`spatstat.geom`**

<blockquote>

The design of the `'ppp'` class specifies that if the `marks` are a `data.frame` with only 1 column, then the `marks` will be converted to a `vector`.

This design choice was made a long time ago, in order to avoid problems that would otherwise occur in the rest of the **`spatstat`** code.

If we were to retrospectively change the specification, we would have a lot of work to do in the rest of the code, and the documentation.

</blockquote>

On the other hand, function `grouped_ppp()` (@sec-grouped_ppp) relies on the support of `ncol`-`1L` `'dataframe'`-`marks`. As an *ad hoc* solution, the authors defined

-   an (internal) derived class `'ppp_tzh'` (initials of T. Zhan) that `inherits` from a `ppp.object`, and
-   an `S3` method dispatch `` `[.ppp_tzh` `` that respects the `ncol`-`1L` `'dataframe'`-`marks`. [The `S3` method dispatch `` `[.ppp_tzh` `` is a teeny-tiny modification of the `S3` method dispatch `` spatstat.geom::`[.ppp` ``. Permision from Dr. Baddeley? [GPL-2](https://cran.r-project.org/web/licenses/GPL-2)?]{style="background-color: #FFFF00"}

In the example below, the name of the mark *`hladr`* is retained, as the column name of the `ncol`-`1L` `'dataframe'`-`marks`, for downstream analysis.

```{r}
#| code-fold: true
#| code-summary: "**Example**: function `grouped_ppp()` with one `mark`"
s_a = wrobel_lung |>
   grouped_ppp(formula = hladr ~ OS + gender + age | patient_id/image_id)
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: support of `ncol`-`1L` `'dataframe'`-`markformat`, name of `mark` retained"
s_a$ppp.[[1L]] |>
  spatstat.geom::markformat.ppp()
s_a$ppp.[[1L]] |>
  spatstat.geom::marks.ppp(drop = FALSE) |> 
  head()
```

### Append to Existing `marks`

The `S3` generic syntactic sugar `append_marks<-()` appends an additional mark to the existing `marks`.

The `S3` method dispatch `append_marks<-.ppp()` appends an additional mark to the existing `marks` of an `ppp.object`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `append_marks<-.ppp()`, no existing marks'
spatstat.data::vesicles |>
  spatstat.geom::print.ppp()
ves = spatstat.data::vesicles
set.seed(12); append_marks(ves) = rlnorm(n = spatstat.geom::npoints.ppp(ves))
ves |> 
  spatstat.geom::print.ppp()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `append_marks<-.ppp()`, existing numeric marks'
spatstat.data::waka |>
  spatstat.geom::print.ppp()
wak = spatstat.data::waka
set.seed(23); append_marks(wak) = rlnorm(n = spatstat.geom::npoints.ppp(wak))
wak |> 
  spatstat.geom::print.ppp()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `append_marks<-.ppp()`, existing `multitype` marks'
spatstat.data::urkiola |>
  spatstat.geom::print.ppp()
urki = spatstat.data::urkiola
set.seed(42); append_marks(urki) = rlnorm(n = spatstat.geom::npoints.ppp(urki))
urki |> 
  spatstat.geom::print.ppp()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `append_marks<-.ppp()`, existing `dataframe` marks'
spatstat.data::stonetools |>
  spatstat.geom::print.ppp()
stonest = spatstat.data::stonetools
set.seed(33); append_marks(stonest) = rlnorm(n = spatstat.geom::npoints.ppp(stonest))
stonest |> 
  spatstat.geom::print.ppp()
```

### Default $r_\text{max}$ {#sec-default_rmax}

The `S3` generic function `rmax_()` provides the default $r_\text{max}$ used in package **`spatstat.explore`** functions that returns an `fv.object`.

The primary `S3` method dispatch `rmax_.ppp()` is

<details>

<summary>An off-label use of functions `spatstat.explore::rmax.rule()` and `spatstat.geom::handle.r.b.args()`</summary>

| Function in package **`spatstat.explore`** | Call of `spatstat.explore::rmax.rule` | Default $r_\text{max}$ via `rmax_()` |
|------------------------|------------------------|------------------------|
| [`Emark` and `Vmark`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Emark.html), [`markcorr`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/markcorr.html), [`markvario`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/markvario.html) | `rmax.rule(fun = 'K', ...)` | `rmax_(fun = 'K')` |
| [`Kcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Kcross.html) , workhorse `Kest` and `Kmulti` | `rmax.rule(fun = 'K', ...)` | `rmax_(fun = 'K')` or `rmax_(fun = 'K', i, j)` |
| [`Gcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Gcross.html), workhorse `Gest` and `Gmulti` | `rmax.rule(fun = 'G', ...)` | `rmax_(fun = 'G')` or `rmax_(fun = 'G', i, j)` |
| [`Jcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Jcross.html), workhorse `Jest` and `Jmulti` | `rmax.rule(fun = 'J', ...)` | `rmax_(fun = 'J')` or `rmax_(fun = 'J', i, j)` |

: Default $r_\text{max}$ from functions in package **`spatstat.explore`** that return an `fv.object`

</details>

The `S3` method dispatch `rmax_.ppp()` finds the default $r_\text{max}$ used by various functions applicable to `ppp.object` and returning an `fv.object`.

```{r}
#| code-fold: true
#| code-summary: "**Example**: function `rmax_.ppp()` for `spatstat.explore::markcorr()` on `double`-mark"
spatstat.data::spruces
r1 = spatstat.data::spruces |>
  spatstat.explore::markcorr() |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2 = spatstat.data::spruces |> 
  rmax_(fun = 'K')
stopifnot(identical(r1, r2))
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: function `rmax_.ppp()` for `spatstat.explore::markcorr()` on `integer`-mark"
spatstat.data::anemones
r1 = spatstat.data::anemones |>
  spatstat.explore::markcorr() |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2 = spatstat.data::anemones |> 
  rmax_(fun = 'K')
stopifnot(identical(r1, r2))
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: function `rmax_.ppp()` for `spatstat.explore::Gcross()` on `multitype`-mark"
spatstat.data::amacrine
r1a = spatstat.data::amacrine |>
  spatstat.explore::Gcross(i = 'on', j = 'off') |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2a = spatstat.data::amacrine |> 
  rmax_(fun = 'G', i = 'on', j = 'off')
stopifnot(identical(r1a, r2a))
r1b = spatstat.data::amacrine |>
  spatstat.explore::Gcross(i = 'off', j = 'on') |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2b = spatstat.data::amacrine |> 
  rmax_(fun = 'G', i = 'off', j = 'on')
stopifnot(identical(r1b, r2b))
r1c = spatstat.data::amacrine |>
  spatstat.explore::Gcross(i = 'on', j = 'on') |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2c = spatstat.data::amacrine |> 
  rmax_(fun = 'G', i = 'on', j = 'on')
stopifnot(identical(r1c, r2c))
r1d = spatstat.data::amacrine |>
  spatstat.explore::Gcross(i = 'off', j = 'off') |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2d = spatstat.data::amacrine |> 
  rmax_(fun = 'G', i = 'off', j = 'off')
stopifnot(identical(r1d, r2d))
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: function `rmax_.ppp()` for `spatstat.explore::Jcross()` on `multitype`-mark"
spatstat.data::paracou
r1a = spatstat.data::paracou |>
  spatstat.explore::Jcross(i = 'adult', j = 'juvenile') |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2a = spatstat.data::paracou |> 
  rmax_(fun = 'J', i = 'adult', j = 'juvenile')
stopifnot(identical(r1a, r2a))
r1b = spatstat.data::paracou |>
  spatstat.explore::Jcross(i = 'juvenile', j = 'adult') |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2b = spatstat.data::paracou |> 
  rmax_(fun = 'J', i = 'juvenile', j = 'adult')
stopifnot(identical(r1b, r2b))
r1c = spatstat.data::paracou |>
  spatstat.explore::Gcross(i = 'juvenile', j = 'juvenile') |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2c = spatstat.data::paracou |> 
  rmax_(fun = 'G', i = 'juvenile', j = 'juvenile')
stopifnot(identical(r1c, r2c))
r1d = spatstat.data::paracou |>
  spatstat.explore::Gcross(i = 'adult', j = 'adult') |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2d = spatstat.data::paracou |> 
  rmax_(fun = 'G', i = 'adult', j = 'adult')
stopifnot(identical(r1d, r2d))
```

Additional `S3` method dispatches are discussed in @sec-ppplist and @sec-default_rmax-hyperframe.

### $k$-Means Clustering {#sec-kmeans}

The `S3` generic function `.kmeans()` performs $k$-means clustering. The authors name this generic function with a prefix `.` because the workhorse function `stats::kmeans()` is not an `S3` generic function. The `S3` generic function `.kmeans()` returns an object of class `'kmeans'` defined in R package **`stats`** shipped with vanilla `r R.version$version.string`. Currently only one `S3` method dispatch `.kmeans.ppp()` is planned.

The `S3` method dispatch `.kmeans.ppp()` has parameters

-   `formula`, $x$- and/or $y$- coordinate(s) and/or (one or more of the) numeric `marks`
-   (optional) `centers`, number of clusters
-   (optional) `clusterSize`, "expected" number of points per cluster.

User should specify one of the two optional parameters `centers` and `clusterSize`. If both are specified, then parameter `clusterSize` takes priority and parameter `centers` is ignored.

Data set *`bei`* from package **`spatstat.data`** has $x$- and $y$-coordinates only, i.e., no `marks`.

```{r}
#| code-fold: true
#| code-summary: '**Data**: *`bei`*'
spatstat.data::bei |>
  spatstat.geom::print.ppp()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `.kmeans.ppp()`; cluster *`bei`* by `~ x`'
spatstat.data::bei |> 
  .kmeans(formula = ~ x, centers = 3L)
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `.kmeans.ppp()`; cluster *`bei`* by `~ x + y`'
spatstat.data::bei |> 
  .kmeans(formula = ~ x + y, centers = 3L)
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `.kmeans.ppp()`; cluster *`bei`* by `~ x + y` and parameter `clusterSize`'
spatstat.data::bei |> 
  .kmeans(formula = ~ x + y, clusterSize = 1000L)
```

Data set *`waka`* from package **`spatstat.data`** has numeric `marks` stored in `'vector'`-format.

```{r}
#| code-fold: true
#| code-summary: '**Data**: *`waka`*'
spatstat.data::waka |>
  spatstat.geom::print.ppp()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `.kmeans.ppp()`; cluster *`waka`* by `~ x + marks`'
spatstat.data::waka |> 
  .kmeans(formula = ~ x + marks, centers = 3L)
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `.kmeans.ppp()`; cluster *`waka`* by `~ x + y + marks`'
spatstat.data::waka |> 
  .kmeans(formula = ~ x + y + marks, centers = 3L)
```

Data set *`shapley`* from package **`spatstat.data`** has three (3) numeric `marks` stored in `'dataframe'`-format.

```{r}
#| code-fold: true
#| code-summary: '**Data**: *`shapley`*'
spatstat.data::shapley |>
  spatstat.geom::print.ppp()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `.kmeans.ppp()`; cluster *`shapley`* by `~ x + y + Mag`'
spatstat.data::shapley |> 
  .kmeans(formula = ~ x + y + Mag, centers = 3L)
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `.kmeans.ppp()`; cluster *`shapley`* by `~ x + Mag + V`'
spatstat.data::shapley |> 
  .kmeans(formula = ~ x + Mag + V, centers = 3L)
```

#### Split by $k$-Means Clustering {#sec-split_kmeans}

The `S3` generic function `split_kmeans()` splits `ppp.object`, `ppplist` (Appendix @sec-ppplist), and `hyperframe` (Appendix @sec-split_kmeans-hyperframe) by $k$-means clustering. The authors use a `subset` of the data set *`flu`* from package **`spatstat.data`** to illustrate the various `S3` method dispatches of `split_kmeans()`.

```{r}
#| code-fold: true
#| code-summary: '**Data**: a `hyperframe` object *`fluM`*'
<<fluM>>
```

The `S3` method dispatch `split_kmeans.default()` splits a `ppp.object` by $k$-means clustering.

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `split_kmeans.default()`'
fluM$pattern[[1L]] |> 
  split_kmeans(formula = ~ x + y, centers = 3L)
```

### Pairwise TjÃ¸stheim's Coefficient

The `S3` generic function `pairwise_cor_spatial()` calculates the nonparametric, rank-based, TjÃ¸stheim's correlation coefficients [@Tjostheim78; @Hubert82] in a pairwise-combination fashion, using the workhorse function `SpatialPack::cor.spatial()` from package **`SpatialPack`** [@SpatialPack].

All `S3` method dispatches return an object of class `'pairwise_cor_spatial'`, which `inherits` from the class `'dist'` defined in package **`stats`** shipped with vanilla `r R.version$version.string`. Such inheritance enables us to make use of existing `S3` method dispatches to class `'dist'`, e.g., `stats:::print.dist()`, `stats:::as.matrix.dist()`, `stats:::format.dist()` and `stats:::labels.dist()`. @tbl-dist explains the motivation of this inheritance, that the class `'pairwise_cor_spatial'` shares intrinsic similarity in data structure as the class `'dist'`.

|   | `'pairwise_cor_spatial'` object | `'dist'` object |
|:-----------------------|:-----------------------|:-----------------------|
| Constant `diag`onal values | of `1`; i.e., perfect correlation | of `0`; i.e., zero distance |

: Similarity in Data Structure, `'pairwise_cor_spatial'` & `'dist'` {#tbl-dist}

The `S3` method dispatch `pairwise_cor_spatial.ppp()` finds the nonparametric TjÃ¸stheim's correlation coefficients from the pairwise-combinations of all numeric `marks` in a `ppp.object`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `pairwise_cor_spatial.ppp()`'
finpines_paircor = spatstat.data::finpines |>
  pairwise_cor_spatial()
```

The `S3` method dispatch `stats:::print.dist()` displays a `'pairwise_cor_spatial'` object.

```{r}
#| code-fold: true
#| code-summary: 'A `pairwise_cor_spatial` object *`finpines_paircor`*'
finpines_paircor
```

The `S3` method dispatch `as.matrix.pairwise_cor_spatial()` returns a `matrix` of pairwise TjÃ¸stheim's coefficients with `diag`onal values of 1. Note that this matrix is ***not*** a `cor`relation matrix, because TjÃ¸stheim's correlation coefficient

-   is nonparametric, i.e., there is no definition of the corresponding `cov`ariance, standard deviation `sd`, nor the conversion `cov2cor` method;
-   does not provide a mathematical mechanism to ensure that this matrix is [positive definite](https://en.wikipedia.org/wiki/Definite_matrix).

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `as.matrix.pairwise_cor_spatial()`'
finpines_paircor |> 
  as.matrix()
```

### `r '\U1f6a7'` Global Envelope Test

`r '\U1f6a7'` [This section is under construction. Expected delivery by 2025-12-31.]{style="background-color: #FFFF00"}

## On `fv.object` {#sec-fv}

Many functions in package **`spatstat.explore`** call the workhorse function `spatstat.explore::fv()` and return an `fv.object`, i.e., an object with `S3` class `'fv'`. In addition to

```{r}
#| message: false
#| code-fold: true
#| code-summary: 'The `S3` method dispatches to `fv.object` defined in package **`spatstat.explore`**'
library(spatstat.explore)
methods(class = 'fv') |> 
  attr(which = 'info', exact = TRUE) |>
  subset.data.frame(subset = from == 'spatstat.explore')
```

Package **`groupedHyperframe`** implements the additional `S3` method dispatches in @tbl-S3_fv,

```{r}
#| code-fold: true
#| code-summary: 'Additional `S3` method dispatches to `fv.object`'
#| label: tbl-S3_fv
S3_fv = methods(class = 'fv') |> 
  attr(which = 'info', exact = TRUE) |>
  subset.data.frame(subset = from == 'groupedHyperframe') |>
  within.data.frame(expr = {
    generic = generic |> sprintf(fmt = '`%s`')
  })
rownames(S3_fv) = rownames(S3_fv) |> 
  sprintf(fmt = '`%s`')
S3_fv |>
  knitr::kable(
    # label = 'tbl-S3_fv', # no use
    caption = '`S3` method dispatches to class `\'fv\'`'
  )
```

### "Black Solid Curve" {#sec-blackSolidCurve}

The `S3` method dispatch `spatstat.explore::plot.fv()` visualizes the recommended function value stored in an `fv.object` as a black-solid-curve. Function `spatstat.explore::fvnames(., a = '.y')` finds the "name" of the black-solid-curve.

```{r}
#| fig-show: hide
#| code-fold: true
#| code-summary: '**Review**: function `spatstat.explore::plot.fv()`'
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  spatstat.explore::plot.fv()
# Figure suppressed to reduce vignette file size
```

```{r}
#| code-fold: true
#| code-summary: "**Review**: function `spatstat.explore::fvnames(., a = '.y')`"
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  spatstat.explore::fvnames(a = '.y')
```

Function `keyval.fv()` finds various function values (default being the black-solid-curve) in an `fv.object`, with the corresponding function argument `spatstat.explore::fvnames(., a = '.x')` as the `vector` `names`. Function `keyval.fv()` is a "psuedo" `S3` method dispatch, because the authors do not have an `S3` generic function `keyval()` defined as of package **`groupedHyperframe`** v`r packageVersion('groupedHyperframe')`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `keyval.fv()`'
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  keyval.fv() |>
  head(n = 3L)
```

Functions `trapz.fv()` and `cumtrapz.fv()` calculate the (cumulative) trapezoidal integration (Appendix @sec-trapz) under the black-solid-curve. They are both "psuedo" `S3` method dispatches, as the workhorse functions `pracma::trapz()` and `pracma::cumtrapz()` are not `S3` generic functions as of package **`pracma`** [@pracma, v`r packageVersion('pracma')`].

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `trapz.fv()`'
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  trapz.fv()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `cumtrapz.fv()`'
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  cumtrapz.fv() |>
  tail(n = 3L)
```

Functions `vtrapz.fv()` and `cumvtrapz.fv()` calculate the (cumulative) average vertical height of the trapezoidal integration (Appendix @sec-vtrapz) under the black-solid-curve. They are both "psuedo" `S3` method dispatches, as the workhorse functions `vtrapz()` and `cumvtrapz()` are not `S3` generic functions as of package **`groupedHyperframe`** v`r packageVersion('groupedHyperframe')`, which is intentionally designed as such to match the behavior of package **`pracma`** [@pracma, v`r packageVersion('pracma')`].

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `vtrapz.fv()`'
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  vtrapz.fv()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `cumvtrapz.fv()`'
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  cumvtrapz.fv() |>
  tail(n = 3L)
```

### Legal $r_\text{max}$ {#sec-legal_rmax}

Function `spatstat.explore::markcorr()` is the workhorse inside functions `Emark()`, `Vmark()` and `markvario()` as of package **`spatstat.explore`** v`r packageVersion('spatstat.explore')`. Function `markcorr()` relies on the un-`export`ed workhorse function `spatstat.explore:::sewsmod()`, whose default `method = "density"` contains the calculation of the ratio of two kernel densities. Due to the floating-point precision of R, such density ratios may have exceptional/illegal returns of

-   `0` from $0/\delta$, or `Inf` from $\delta/0$, with a [real number](https://en.wikipedia.org/wiki/Real_number) $\delta\geq$ (approximately) `2.6e-324`
-   `NaN` from $0/\varepsilon$ or $\varepsilon/0$, with a real number $\varepsilon\leq$ (approximately) `2.5e-324`

```{r}
#| code-fold: true
#| code-summary: "**Review**: exceptional/illegal ratio due to floating-point precision"
0 / c(2.6e-324, 2.5e-324)
c(2.5e-324, 2.6e-324) / 0
```

Function `spatstat.explore::markcorr()` provides a default argument of parameter $r$-`vector` (Appendix @sec-default_rmax), at which the mark correlation function $k_f(r)$ are evaluated. The `S3` method dispatch `spatstat.explore::print.fv()` prints the *recommended range* and *available range* of $r$-`vector`.

```{r}
#| code-fold: true
#| code-summary: "**Review**: function `spatstat.explore::print.fv()`"
spatstat.data::spruces |> 
  spatstat.explore::markcorr()
```

Exceptional/illegal values of `0`, `Inf` and/or `NaN` may appear in the mark correlation function $k_f(r)$, if the $r$-`vector` goes beyond the recommended and/or available range.

```{r}
#| code-fold: true
#| code-summary: "**Review**: exceptional/illegal function values *`iso`* when $r$ is out-of-range"
spatstat.data::spruces |> 
  spatstat.explore::markcorr(r = 0:100) |>
  spatstat.explore::as.data.frame.fv() |>
  tail(n = 30L)
```

The helper function `lastLegal()` returns the *index* of the last *consecutive* legal values in a `double` `vector`, i.e., the first exceptional/illegal value of `0`, `Inf`, or `NaN` appears at the next index. "Legal" in function `lastLegal()` is defined as a `double` scalar being not-`NaN`, not-`Inf`, and with `abs`olute value greater than `.Machine$double.eps`.

```{r}
#| code-fold: true
#| code-summary: '**Review**: `NaN` and `Inf` are `double`, not `integer`'
Inf |> typeof()
NaN |> typeof()
```

```{r}
#| code-fold: true
#| code-summary: '**Advanced**: `lastLegal()`, definition of `legal`; and behavior of `base::is.finite()`'
as.list(body(lastLegal))[[2L]]
c(NA_real_, NaN, Inf) |>
  is.finite()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `lastLegal()`, toy examples'
c(exp(1), pi) |> 
  lastLegal()
c(exp(1), pi, NaN) |> 
  lastLegal()
c(exp(1), pi, NaN, 1, 0, Inf) |> 
  lastLegal()
```


```{r}
#| echo: false
#| results: hide
#| label: lastLegal_keyval
spruces_markcorr_lastLegal = spatstat.data::spruces |> 
  spatstat.explore::markcorr(r = 0:100) |>
  keyval.fv() |>
  lastLegal()
```


The term *Legal $r_\text{max}$* is (the index) of the $r$-`vector`, where the last of the consecutive legal function values appears. In the example below, the last consecutive legal function value of `r spruces_markcorr_lastLegal |> attr('value') |> sprintf(fmt = '$k_f(r)=%.3f$')` appears at the `r spruces_markcorr_lastLegal`-th index of the $r$-`vector`, i.e., `r spruces_markcorr_lastLegal |> attr('value') |> names() |> sprintf(fmt = '$r=%s$')`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `lastLegal()` of `keyval.fv()`'
<<lastLegal_keyval>>
spruces_markcorr_lastLegal
```

Legality of the function `spatstat.explore::markcorr()` returns depends not only on the input `ppp.object`, but also on the values of the $r$-`vector`. In other words, the creation of an `fv.object` by function `markcorr()` is a numerical procedure. Therefore, the discussion of Legal $r_\text{max}$ pertains to `fv.object` (Appendix @sec-fv), instead of to `ppp.object` (Appendix @sec-ppp).

```{r}
#| code-fold: true
#| code-summary: '**Example**: Legality of `spatstat.explore::markcorr()` return depends on $r$'
spatstat.data::spruces |> 
  spatstat.explore::markcorr(r = seq.int(from = 0, to = 100, by = .1)) |>
  keyval.fv() |>
  lastLegal()
```

## On `anylist`

Function `spatstat.geom::anylist()` returns an object of `S3` class `'anylist'`, which `inherits` from the class `'listof'`.

The authors discuss some extensions of the class `'anylist'` in this section.

### On `solist` {#sec-solist}

Function `spatstat.geom::solist()` returns an object of `S3` class `'solist'`, i.e., list of two-dimensional spatial objects. The `S3` class `'solist'` `inherits` from the class `'anylist'`.

The authors plan [**not**]{style="background-color: #FFFF00"} to implement

-   an `S3` method dispatch of `marks()` to the class `'solist'` (Appendix @sec-dont-marks-solist).

#### On `ppplist` {#sec-ppplist}

An `S3` derived class `'ppplist'`, e.g., class of the returned object from function `spatstat.geom::split.ppp()`, etc., `inherits` from the `S3` class `'solist'`. A `'ppplist'` is a `listof` two-dimensional point pattern `ppp.object`s.

The `S3` generic function `rmax_()` has been introduced in Appendix @sec-default_rmax. The `S3` method dispatch `rmax_.ppplist()` obtains the default $r_\text{max}$ *before* the (potentially) very slow batch processes.

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `rmax_.ppplist()`'
spatstat.data::btb.extra$full |> 
  markcorr() |> 
  vapply(FUN = \(i) {
    i |> 
      spatstat.explore::with.fv(expr = r) |> 
      max()
  }, FUN.VALUE = NA_real_)
spatstat.data::btb.extra$standard |> 
  markcorr() |> 
  vapply(FUN = \(i) {
    i |> 
      spatstat.explore::with.fv(expr = r) |> 
      max()
  }, FUN.VALUE = NA_real_)
spatstat.data::btb.extra |> 
  rmax_(fun = 'K')
```

The `S3` generic function `split_kmeans()` has been introduced in Appendix @sec-split_kmeans. The `S3` method dispatch `split_kmeans.listof()` splits a `ppplist` by $k$-means clustering. The authors use a `subset` of the data set *`flu`* from package **`spatstat.data`** to illustrate this concept. The returned object has `attributes`

-   `attr(.,'.id')`, indices of the `ppp.object`s before splitting.
-   `attr(.,'.cluster')`, indices of $k$-means clusters, nested in `.id`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `split_kmeans.listof()`'
<<fluM>>
fluM$pattern |> 
  split_kmeans(formula = ~ x + y, centers = 3L) 
```

### Derived Class `'vectorlist'` {#sec-vectorlist}

The derived class `'vectorlist'`, i.e., a `listof` `vector`s, `inherits` from the class `'anylist'`. The implementation of the class `'vectorlist'` is inspired by the class `'solist'`. The authors use the `character`-hypercolumn *`values`* of data set *`Kovesi`* from package **`spatstat.data`** to illustrate this concept.

```{r}
#| code-fold: true
#| code-summary: '**Data**: a `hyperframe` object *`Kovesi`*'
spatstat.data::Kovesi |>
  head()
```

The `character`-hypercolumn *`Kovesi$values`* has the class `'anylist'`. This is a `length`-41 `listof` `character` `vector`s of equi-`length`, i.e., all `vector`-elements have `length`-256.

```{r}
#| code-fold: true
#| code-summary: '**Data**: an `anylist` object *`Kovesi$values`*'
spatstat.data::Kovesi$values |>
  class()
spatstat.data::Kovesi$values |>
  length()
spatstat.data::Kovesi$values |>
  lengths() |>
  unique.default()
```

The authors create an object *`Kovesi_values`* of a derived class `'vectorlist'`.

```{r}
#| code-fold: true
#| code-summary: '**Data**: a `vectorlist` object *`Kovesi_values`*'
Kovesi_values = spatstat.data::Kovesi$values
class(Kovesi_values) = c('vectorlist', class(Kovesi_values))
Kovesi_values |> 
  class()
```

The `S3` method dispatch `t.vectorlist()` transposes a `vectorlist` of equi-`length` into another `vectorlist`, but with the `length` and `lengths` of the input switched. The use of the term "transpose", and the extension of the generic function `base::t()`, mirrors the use of the default dispatch `base:::t.default()` to transpose a `matrix`, i.e., to switch the `ncol` and `nrow` of the input. The returned object *`Kovesi_values_t`* is a `length`-256 `listof` `vector`s, all elements of which have `length`-41.

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `t.vectorlist()`'
#| label: t-vectorlist
Kovesi_values_t = Kovesi_values |> 
  t()
Kovesi_values_t |>
  class()
Kovesi_values_t |>
  length()
Kovesi_values_t |>
  lengths() |>
  unique.default()
```

The motivation of the derived class `'vectorlist'` and the `S3` method dispatch `t.vectorlist()` is that the function `spatstat.geom::with.hyperframe()` could be slow in a batch process.

```{r}
#| code-fold: true
#| code-summary: 'Transposed element 1'
z1 = spatstat.data::Kovesi |> 
  spatstat.geom::with.hyperframe(expr = values[1L])
stopifnot(identical(Kovesi_values_t[[1L]], z1))
```

```{r}
#| code-fold: true
#| code-summary: 'Transposed element 2'
z2 = spatstat.data::Kovesi |> 
  spatstat.geom::with.hyperframe(expr = values[2L])
stopifnot(identical(Kovesi_values_t[[2L]], z2))
```

```{r}
#| code-fold: true
#| code-summary: 'Transposed element 256'
z256 = spatstat.data::Kovesi |> 
  spatstat.geom::with.hyperframe(expr = values[256L])
stopifnot(identical(Kovesi_values_t[[256L]], z256))
```

The derived class `'vectorlist'` is not part of package **`spatstat.geom`** as of dev v`r packageVersion('spatstat.geom')`. Readers may call the `S3` method dispatch `t.vectorlist()` explicitly as a workaround before package **`spatstat.geom`** (ever) implements the class `vectorlist`.

```{r}
#| code-fold: true
#| code-summary: "**Workaround**: without derived class `'vectorlist'`"
Kovesi_values_t2 = spatstat.data::Kovesi$values |>
  t.vectorlist()
stopifnot(identical(Kovesi_values_t, Kovesi_values_t2))
```

### Derived Class `'fvlist'` {#sec-fvlist}

The derived class `'fvlist'`, i.e., a `listof` function value table `fv.object`s, `inherits` from the class `'anylist'`. The implementation of the class `'fvlist'` is inspired by the class `'solist'`.

As of package **`spatstat.geom`** v`r packageVersion('spatstat.geom')`, an `fv`-hypercolumn in a `hyperframe` has class `c('anylist, 'listof', 'list')`. The authors may try to convince [Prof. Adrian Baddeley](https://en.wikipedia.org/wiki/Adrian_Baddeley) [@spatstat05] to [support the class `'fvlist'` in function `spatstat.geom::hyperframe()`]{style="background-color: #FFFF00"}, so that an `fv`-hypercolumn shall have class `c('fvlist', 'anylist, 'listof', 'list')`. Before this happens, the authors propose some workaround in package **`groupedHyperframe`**, so that active developers could make use of the `S3` method dispatches to the class `'fvlist'`.

The authors use a `subset` of the data set *`flu`* from package **`spatstat.data`** to illustrate this concept.

```{r}
#| code-fold: true
#| code-summary: '**Data**: a `hyperframe` object *`fluM`*'
<<fluM>>
```

The `ppp`-hypercolumn *`fluM$pattern`* contains `ppp.object`s with `multitype` `marks`.  A batch process (@sec-batch) applicable to `multitype` `marks`, e.g., `Gcross_()`, adds an `fv`-hypercolumn *`m.G`* to the input `hyperframe` *`fluM`*. The `message` of "Legal $r_\text{max}$" provides the indices in the `fv`-hypercolumn, i.e., the row indices of the `hyperframe`, where the legal $r_\text{max}$ (Appendix @sec-legal_rmax) is smaller than the maximum value of the user-specified $r$-`vector`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `Gcross_()`'
r = seq.int(from = 0, to = 100, by = 5)
fluM_G = fluM |>
  Gcross_(i = 'M1', j = 'M2', r = r)
fluM_G
```

```{r}
#| code-fold: true
#| code-summary: "**Future**: `fv`-hypercolumn is (not yet!) an `'fvlist'`"
fluM_G$m.G |>
  class() # not yet :)
```

#### Validity

Function `as.fvlist()` inspects a `listof` `fv.object`s and convert it to an object of class `'fvlist'`. To qualify as an `fvlist`, all the members of `fv.object`s in the `list` must have `identical`

-   names of function argument, i.e., returns of `spatstat.explore::fvnames(., a = '.x')`;
-   function arguments, i.e., the values of the $r$-`vector`;
-   names of recommended function value, i.e., returns of `spatstat.explore::fvnames(., a = '.y')`;
-   function names and additional information, i.e., returns of `attr(.,'fname')`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `as.fvlist()`'
m_G = fluM_G$m.G |>
  as.fvlist()
m_G |> 
  class()
```

The class `'fvlist'` has `attributes`

-   `attr(.,'r')`, a `numeric` `vector`, the `identical` values of $r$-vector in all `fv.object`s;
-   `attr(.,'.x')`, a `character` scalar, the name of the function argument, i.e., the `identical` returns of `spatstat.explore::fvnames(., a = '.x')` from all `fv.object`s;
-   `attr(.,'.y')`, a `character` scalar, the name of the recommended function value, i.e., the `identical` returns of `spatstat.explore::fvnames(., a = '.y')` from all `fv.object`s;
-   `attr(.,'fname')`, a `character` scalar or `vector`, the function name and additional information, i.e., the `identical` returns of `attr(.,'fname')` from all `fv.object`s;
-   `attr(.,'rmax')`, a `numeric` scalar, the minimum Legal $r_\text{max}$ (Appendix @sec-legal_rmax) of all `fv.object`s.  Obviously, the minimum Legal $r_\text{max}$ `attr(.,'rmax')` is less than or equal to the maximum value of the $r$-vector `attr(.,'r')`.

```{r}
#| code-fold: true
#| code-summary: "**Advanced**: `base::attributes()` of class `'fvlist'`"
m_G |> 
  attributes()
```

The `S3` method dispatch `print.fvlist()` prints the vital information of an `'fvlist'`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `print.fvlist()`'
m_G
```


#### Truncated Summary {#sec-summary_fvlist}

The `S3` method dispatch `summary.fvlist()` performs a *truncated summary* at a user-specified $r_\text{max}$ `rmax` and returns a `list` with elements

-   *`$y`*, the (truncated) function values, i.e., the black-solid-curve (Appendix @sec-blackSolidCurve), per `fv.object`;
-   *`$cumtrapz`*, the (truncated) cumulative trapezoidal integration after removing the first `0`-value (Appendix @sec-trapz), per `fv.object`;
-   *`$cumvtrapz`*, the (truncated) cumulative average vertical height of trapezoidal integration after removing the first `NaN`-value (Appendix @sec-vtrapz), per `fv.object`.

Specifically, the *truncation* is performed under the following rules,

-   if user-specified $r_\text{max}$ `rmax` is `missing`, then the `fv.object`s are truncated at the minimum Legal $r_\text{max}$ `attr(.,'rmax')`.
-   if user-specified $r_\text{max}$ `rmax` is greater than the minimum Legal $r_\text{max}$ `attr(.,'rmax')`, then the `fv.object`s are truncated at the minimum Legal $r_\text{max}$ `attr(.,'rmax')` and the user `rmax` is ignored.
-   if user-specified $r_\text{max}$ `rmax` is less than or equal to the minimum Legal $r_\text{max}$ `attr(.,'rmax')`, then the `fv.object`s are truncated at the user `rmax`.


```{r}
#| code-fold: true
#| code-summary: '**Example**: function `summary.fvlist()`, user $r_\text{max}>$ minimum Legal $r_\text{max}$'
m_G_s1 = m_G |>
  summary(rmax = 85)
m_G_s1 |> 
  lapply(FUN = head, n = 2L)
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `summary.fvlist()`, user $r_\text{max}\leq$ minimum Legal $r_\text{max}$'
m_G_s2 = m_G |>
  summary(rmax = 70)
m_G_s2 |> 
  lapply(FUN = head, n = 2L)
```

The truncated summary is important, because the exceptional/illegal function values (Appendix @sec-legal_rmax) cause problems in downstream analyses.  Readers are encouraged to learn more about these analyses from package **`hyper.gam`** vignette ([RPubs](https://rpubs.com/tingtingzhan/hyper_gam), [CRAN](https://CRAN.R-project.org/package=hyper.gam/vignettes/applications.html)) and package **`maxEff`** vignette ([RPubs](https://rpubs.com/tingtingzhan/maxEff), [CRAN](https://CRAN.R-project.org/package=maxEff/vignettes/intro.html)).


## On `hyperframe` {#sec-hyperframe}

Function `spatstat.geom::hyperframe()` returns a `hyperframe`, i.e., an object with `S3` class `'hyperframe'`. Among

```{r}
#| message: false
#| code-fold: true
#| code-summary: "The `S3` method dispatches to class `'hyperframe'` defined in package **`spatstat.geom`**"
library(spatstat.geom)
methods(class = 'hyperframe') |> 
  attr(which = 'info', exact = TRUE) |>
  subset.data.frame(subset = from == 'spatstat.geom')
```

Several of them behave *very differently* from their counterpart in vanilla `r R.version.string`. Readers are strongly advised to read the documentation of these functions from package **`spatstat.geom`**.

<details>

<summary>The `S3` method dispatches `spatstat.geom::*.hyperframe()` that are drastically different from `*.data.frame()` or `*.default()`</summary>

| Generic Function | Method Dispatch to `'data.frame'` | Method Dispatch to `'hyperframe'` |
|------------------------|------------------------|------------------------|
| [`` base::`[` ``](https://search.r-project.org/R/refmans/base/html/Extract.html) | [`` base::`[.data.frame` ``](https://search.r-project.org/R/refmans/base/html/Extract.data.frame.html) | [`` spatstat.geom::`[.hyperframe` ``](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/Extract.hyperframe.html) |
| [`` base::`$<-` ``](https://search.r-project.org/R/refmans/base/html/Extract.html) | [`` base::`$<-.data.frame` ``](https://search.r-project.org/R/refmans/base/html/Extract.data.frame.html) | [`` spatstat.geom::`$<-.hyperframe` ``](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/Extract.hyperframe.html) |
| [`base::subset`](https://search.r-project.org/R/refmans/base/html/subset.html) | [`base::subset.data.frame`](https://search.r-project.org/R/refmans/base/html/subset.html) | [`spatstat.geom::subset.hyperframe`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/subset.hyperframe.html) |
| [`base::with`](https://search.r-project.org/R/refmans/base/html/with.html) | [`base::with.default`](https://search.r-project.org/R/refmans/base/html/with.html) | [`spatstat.geom::with.hyperframe`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/with.hyperframe.html) |
| [`base::within`](https://search.r-project.org/R/refmans/base/html/with.html) | [`base::within.data.frame`](https://search.r-project.org/R/refmans/base/html/with.html) | do not exist (as of v`r packageVersion('spatstat.geom')`) |

: `S3` methods `*.hyperframe()` that are drastically different from `*.data.frame()` or `*.default()`

</details>

Package **`groupedHyperframe`** implements the additional `S3` method dispatches in @tbl-S3_hyperframe,

```{r}
#| message: false
#| code-fold: true
#| code-summary: "Additional `S3` method dispatches to class `'hyperframe'`"
#| label: tbl-S3_hyperframe
library(spatstat.geom) # must! for S3 generic function `spatstat.geom::superimpose`
S3_hyperframe = methods(class = 'hyperframe') |> 
  attr(which = 'info', exact = TRUE) |>
  subset.data.frame(subset = from == 'groupedHyperframe') |>
  within.data.frame(expr = {
    generic = generic |> sprintf(fmt = '`%s`')
  })
rownames(S3_hyperframe) = rownames(S3_hyperframe) |> 
  sprintf(fmt = '`%s`')
S3_hyperframe |>
  knitr::kable(
    # label = 'tbl-S3_hyperframe', # no use! 
    caption = '`S3` method dispatches to class `\'hyperframe\'`'
  )
```

The authors plan [**not**]{style="background-color: #FFFF00"} to implement

-   an `S3` method dispatch of `as.environment()` to the class `'hyperframe'` (Appendix @sec-dont-asenvironment-hyperframe).
-   an `S4` method dispatch of `merge()` to the classes `'hyperframe'` and/or `'groupedHyperframe'` (Appendix @sec-dont-merge-hyperframe).

### Convert to `groupedHyperframe` {#sec-asgroupedHyperframe-hyperframe}

The S3 generic function `as.groupedHyperframe()` has been introduced in @sec-groupedHyperframe. The `S3` method dispatch `as.groupedHyperframe.hyperframe()` converts a `hyperframe` into a `groupedHyperframe`. This function simply inspects and adds a (nested) grouping structure to the input `hyperframe`. Data set *`osteo`* from package **`spatstat.data`** has the serial number of sampling volume `brick` nested in the bone sample `id`, i.e., a nested grouping structure `~id/brick`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `as.groupedHyperframe.hyperframe()`'
spatstat.data::osteo |> 
  as.groupedHyperframe(group = ~ id/brick)
```

### Superimpose

The `S3` method dispatch `superimpose.hyperframe()`, which does not exist in package **`spatstat.geom`** as of v`r packageVersion('spatstat.geom')`, superimposes multiple `hyperframe`s if-and-only-if they have `identical`

-   `dim`ensions, i.e., `spatstat.geom::dim.hyperframe()`
-   columns, i.e., `unclass(.)$df`
-   `names` and `class` of the `hypercolumn`s, i.e., `unclass(.)$hypercolumns`

The `S3` method dispatch `superimpose.groupedHyperframe()` superimposes multiple `groupedHyperframe`s if-and-only-if they satisfy the *additional* criteria that they have `identical`

-   grouping structures, i.e., `attr(.,'group')`

The authors use a `subset` of the data set *`flu`* from package **`spatstat.data`** to illustrate the superimpose of `hyperframe`s.

```{r}
#| label: fluM
#| code-fold: true
#| code-summary: '**Data**: a `hyperframe` object *`fluM`*'
fluM = spatstat.data::flu |>
  spatstat.geom::subset.hyperframe(subset = (stain == 'M2-M1') & (virustype == 'wt'))
fluM
```

The `hyperframe` *`fluM`* contains `r nrow(fluM)` subjects, each of them has a `ppp.object` with 200-500 points.

```{r}
#| code-fold: true
#| code-summary: '**Review**: number of points per `ppp.object` in hypercolumn *`fluM$pattern`*'
fluM$pattern |>
  sapply(FUN = spatstat.geom::npoints.ppp)
```

```{r}
#| code-fold: true
#| code-summary: '**Review**: number of *`M1`* and/or *`M2`* points per `ppp.object` in hypercolumn *`fluM$pattern`*'
fluM$pattern |>
  sapply(FUN = \(i) {
    i |> 
      spatstat.geom::marks.ppp() |> 
      table()
  }) |>
  addmargins()
```

The authors create a `hyperframe` *`fluM1`* which consists of the same columns as *`fluM`*, but a `ppp`-hypercolumn *`pattern`* with *`M1`* marks only. Similarly, the authors create another `hyperframe` *`fluM2`* which consists of the *`M2`* marks only. Note that as of package **`spatstat.geom`** v`r packageVersion('spatstat.geom')`, the tedious code below is the only way to avoid using the row names of hyperframe as the element-names of the hypercolumns. In other words, function `unclass()` avoids invoking the `S3` method dispatch `` spatstat.geom::`$.hyperframe`() ``. The `S3` method dispatch `` spatstat.geom::`$<-.hyperframe` `` is fine in this application.

```{r}
#| code-fold: true
#| code-summary: '**Data**: two `hyperframe` objects *`fluM1`* and *`fluM2`*'
fluM1 = fluM2 = fluM
fluM1$pattern = unclass(fluM)$hypercolumns$pattern |> 
  spatstat.geom::solapply(FUN = spatstat.geom::subset.ppp, subset = (marks == 'M1'))
fluM2$pattern = unclass(fluM)$hypercolumns$pattern |> 
  spatstat.geom::solapply(FUN = spatstat.geom::subset.ppp, subset = (marks == 'M2'))
```

```{r}
#| code-fold: true
#| code-summary: '**Review**: number of *`M1`* points per `ppp.object` in hypercolumn *`fluM1$pattern`*'
fluM1$pattern |>
  sapply(FUN = spatstat.geom::npoints.ppp)
```

```{r}
#| code-fold: true
#| code-summary: '**Review**: number of *`M2`* points per `ppp.object` in hypercolumn *`fluM2$pattern`*'
fluM2$pattern |>
  sapply(FUN = spatstat.geom::npoints.ppp)
```

The `S3` method dispatch `superimpose.hyperframe()` recreates the `hyperframe` *`fluM`* by combining the `hyperframe`s *`fluM2`* and *`fluM1`*. Note that the order of *`fluM2`*-then-*`fluM1`* matters, because the points are arranged in *`M2`*-then-*`M1`* in the original hypercolumn *`fluM$pattern`*.

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `superimpose.hyperframe()`'
fluS = superimpose.hyperframe(fluM2, fluM1)
stopifnot(identical(fluS, fluM))
```

### Default $r_\text{max}$ {#sec-default_rmax-hyperframe}

The `S3` generic function `rmax_()` has been introduced in Appendix @sec-default_rmax. The `S3` method dispatch `rmax_.hyperframe()` obtains the default $r_\text{max}$ *before* the (potentially) very slow batch processes.

```{r}
#| code-fold: true
#| code-summary: "**Example**: function `rmax_.hyperframe()` for `Emark_()`, `Vmark_()`, `markcorr_()`, `markvario_()` on numeric (and `multitype`) mark"
s |> rmax_(fun = 'K')
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: function `rmax_.hyperframe()` for `Kcross_()` on `multitype` mark"
s |> rmax_(fun = 'K', i = 'CK+.CD8-', j = 'CK-.CD8+')
s |> rmax_(fun = 'K', i = 'CK-.CD8+', j = 'CK+.CD8-')
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: function `rmax_.hyperframe()` for `Gcross_()` on `multitype` mark"
s |> rmax_(fun = 'G', i = 'CK+.CD8-', j = 'CK-.CD8+')
s |> rmax_(fun = 'G', i = 'CK-.CD8+', j = 'CK+.CD8-')
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: function `rmax_.hyperframe()` for `Jcross_()` on multitype mark"
s |> rmax_(fun = 'J', i = 'CK+.CD8-', j = 'CK-.CD8+')
s |> rmax_(fun = 'J', i = 'CK-.CD8+', j = 'CK+.CD8-')
```

### Split by $k$-Means Clustering {#sec-split_kmeans-hyperframe}

The `S3` generic function `split_kmeans()` has been introduced in Appendix @sec-split_kmeans. The `S3` method dispatch `split_kmeans.hyperframe()` splits a `hyperframe` and/or `groupedHyperframe` by $k$-means clustering of the *one-and-only-one* `ppp`-hypercolumn. The returned object is a `groupedHyperframe` with grouping structure

-   `~.id/.cluster`, if the input is a `hyperframe`
-   `~ <existing/grouping/structure>/.cluster`, if the input is a `groupedHyperframe`. Note that the grouping level `.id` is **believed** to be equivalent to *the lowest level of existing grouping structure*.

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `split_kmeans.hyperframe()`'
<<fluM>>
fluM |> 
  split_kmeans(formula = ~ x + y, centers = 3L)
```

## On `groupedHyperframe` {#sec-groupedHyperframe-appendix}

### Nested Grouping Structure {#sec-nestedGroup}

The nested grouping structure $g_1/.../g_m$ (`~g1/.../gm`) is explained in section *Details* of [`stats::formula`](https://search.r-project.org/R/refmans/stats/html/formula.html) documentation. The nested grouping structure is made well known by the parameter `random` of functions `nlme::lme()` and `nlme::nlme()`. In fact, the 'grouped' extension of the class `'hyperframe'` is inspired by the class `'groupedData'` defined in package **`nlme`** [@nlme], which `inherits` from the class `'data.frame'`.

Package **`groupedHyperframe`** allows interaction terms using colon operator `:` in the (nested) grouping structure, e.g., `~g1/g2a:g2b/g3a:g3b:g3c`. This feature is made possible because the colon operator `:` has higher priority than the forward slash `/` in R `formula`. In the meanwhile, user should be aware that the tilde operator `~` has *lower* priority than the forward pipe `|>` in R `formula`.

```{r}
#| code-fold: true
#| code-summary: "**Review**: colon operator `:` has higher priority than forward slash `/`"
quote(g1/g2a:g2b/g3a:g3b:g3c) |>
  as.list()
```

```{r}
#| code-fold: true
#| code-summary: "**Review**: tilde operator `~` has *lower* priority than forward pipe `|>`"
~ x |> foobar() # wrong!
quote((~ x) |> foobar()) # correct
```

Function `get_nested()` breaks down a nested grouping structure by the forward slash `/`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `get_nested()`'
quote(g1/g2/g3) |>
  get_nested()
(~g1/g2/g3) |>
  get_nested()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `get_nested()` with interaction terms'
quote(g1/g2a:g2b/g3a:g3b:g3c) |>
  get_nested()
(~g1/g2a:g2b/g3a:g3b:g3c) |>
  get_nested()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: function `get_nested()`, exception handling'
(~a) |> get_nested()
(~b:c) |> get_nested()
```

The (nested) grouping structure `attr(.,'group')` of a `groupedHyperframe`

-   must denote the highest level using a `symbol` (e.g., `g1`)
-   may denote the lower levels using a `symbol` (e.g., `g2`) or an interaction-term (e.g., `g2a:g2b`)

# What We Don't Do

The authors keep note of the features **not** planned to be support in package **`groupedHyperframe`**. Those features are technically tedious to implement, and/or have relatively easy workaround.

## For `ppp.object` {#sec-dont-ppp}

### Missing `marks` Handling {#sec-dont-na-ppp}

Other than the `S3` method dispatches `na.omit.ppp()` and `na.exclude.ppp()` (Appendix @sec-na-ppp), the authors have [**not**]{style="background-color: #FFFF00"} implemented the `S3` method dispatches `na.fail` and `na.pass` to a `ppp.object`. The authors may implement one or both of them in future.

## For `'solist'` {#sec-dont-solist}

### `S3` method dispatch of `marks()` {#sec-dont-marks-solist}

The authors plan [**not**]{style="background-color: #FFFF00"} to implement an `S3` method dispatch `marks` to the class `'solist'`.

The data set *`btb.extra`* from package **`spatstat.data`** is a `ppplist`, which `inherits` from the class `'solist'`. The `ppp`-hypercolumn of the `hyperframe` *`flu`* from package **`spatstat.data`** is another `ppplist`.

```{r}
#| code-fold: true
#| code-summary: '**Data**: a `ppplist` object *`btb.extra`*'
spatstat.data::btb.extra
spatstat.data::btb.extra |> 
  class()
```

```{r}
#| code-fold: true
#| code-summary: '**Data**: a `ppplist` object, as `ppp`-hypercolumn, *`flu$pattern`*'
spatstat.data::flu$pattern |>
  head(n = 3L)
spatstat.data::flu$pattern |>
  class()
```

The `S3` method dispatch `spatstat.geom::marks.ppp()` obtains the `marks` in each `ppp`-element of the `ppplist` *`btb.extra`* and of the `ppp`-hypercolumn *`flu$pattern`*.

```{r}
#| code-fold: true
#| code-summary: '**Review**: `marks` in *`btb.extra$full`*'
spatstat.data::btb.extra$full |> 
  spatstat.geom::marks.ppp() |>
  head()
```

```{r}
#| code-fold: true
#| code-summary: '**Review**: `marks` in *`flu$pattern[[1L]]`*'
spatstat.data::flu$pattern[[1L]] |> 
  spatstat.geom::marks.ppp() |>
  head()
```

To obtain the `marks` from all `ppp`-elements of a `ppplist`, the authors suggest using the function `base::lapply()` as a workaround, e.g.,

```{r}
#| results: hide
#| code-fold: true
#| code-summary: '**Workaround**: `marks` in *`btb.extra`*'
spatstat.data::btb.extra |>
  lapply(FUN = spatstat.geom::marks.ppp)
# result suppressed to save vignette space
```

```{r}
#| results: hide
#| code-fold: true
#| code-summary: '**Workaround**: `marks` in *`flu$pattern`*'
spatstat.data::flu$pattern |>
  lapply(FUN = spatstat.geom::marks.ppp)
# result suppressed to save vignette space
```

## For `'hyperframe'` {#sec-dont-hyperframe}

### `S3` method dispatch of `as.environment()` {#sec-dont-asenvironment-hyperframe}

The authors plan [**not**]{style="background-color: #FFFF00"} to write an `S3` method dispatch `as.environment` to the class `'hyperframe'`, as it would be a simple pipeline of functions `spatstat.geom::as.list.hyperframe()` and `base::list2env()`.

```{r}
#| code-fold: true
#| code-summary: '**Workaround**: `as.environment` of `hyperframe`'
ev = spatstat.data::demohyper |> 
  spatstat.geom::as.list.hyperframe() |>
  list2env()
ev |> 
  as.list.environment() |>
  lapply(FUN = class)
```

### `S4` method dispatch of `merge()` {#sec-dont-merge-hyperframe}

The authors plan [**not**]{style="background-color: #FFFF00"} to implement an `S4` method dispatch `merge` to `hyperframe` and/or `groupedHyperframe` classes, for the obstacles explained below.

First, there is not an `S3` method dispatch `merge.hyperframe` in package **`spatstat.geom`** (as of v`r packageVersion('spatstat.geom')`);

Second, should the authors decide to implement `setMethod(f = merge, ...)` for the class `'hyperframe'`, at least two (2) `S4` method dispatches need to be written for

-   `signature = c(x = 'hyperframe', y = 'data.frame')`
-   `signature = c(x = 'hyperframe', y = 'hyperframe')`, for which the authors need to define a `match` mechanism for hypercolumns.

Lastly, should the authors decide to implement `setMethod(f = merge, ...)` for the class `'groupedHyperframe'`, at least three (3) `S4` method dispatches need to be written for

-   `signature = c(x = 'groupedHyperframe', y = 'data.frame')`
-   `signature = c(x = 'groupedHyperframe', y = 'hyperframe')`, as explained above;
-   `signature = c(x = 'groupedHyperframe', y = 'groupedHyperframe')`, for which the authors need to consider the (potentially different) grouping structures of `x` and `y` inputs.

The authors suggest using the pipeline of functions `base::merge.data.frame()` and `as.groupedHyperframe()` as a workaround.

# Terms & Abbreviations {#sec-terms}

## in Math {#sec-mathterm}

@tbl-mathterm presents some mathematical symbols, as well as their [LaTeX](https://www.latex-project.org) source code, used in this vignette. These symbols should be familiar to the audience with an advanced degree in mathematics.

| Symbol | [LaTeX](https://www.latex-project.org) Source | Example | Translate To |
|:-----------------|:-----------------|:-----------------|:-----------------|
| $\Delta$ | `$\Delta$` | $\Delta x_k= x_k - x_{k-1}$ | Delta-$x_k$ is defined as the difference between $x_k$ and $x_{k-1}$ |
| $\equiv$ | `$\equiv$` | $x\equiv a$ | Variable $x$ is equivalent to constant $a$ |
| $\forall$ | `$\forall$` | $\forall k$ | For all $k$ |
| $\iff$ | `$\iff$` | $A\iff B$ | $A$ is true, if and only if $B$ is true |

: Terms & Abbreviations in Mathematics {#tbl-mathterm}

## in R {#sec-Rterms}

@tbl-Rterm presents a comprehensive glossary of R terms and abbreviations used in this vignette.

R terminology and nomenclature could be *drastically different* from that of mathematics and statistics. Readers are *strongly advised* to read closely from the links in @tbl-Rterm, most of which point to webpages on [search.r-project.org](https://search.r-project.org), [cran.r-project.org](https://cran.r-project.org), [adv-r.hadley.nz](https://adv-r.hadley.nz) and [en.wikipedia.org](https://en.wikipedia.org).

| Term / Abbreviation | Description |
|:-----------------------------------|:-----------------------------------|
| CRAN, R | The Comprehensive R Archive Network, <https://cran.r-project.org> |
| `Depends`, `Imports`, `Suggests`, `Enhances` | [*Writing R Extensions*, Section 1.1.3 *Package Dependencies*](https://cran.r-project.org/doc/manuals/r-devel/R-exts.html#Package-Dependencies) |
| [`|>`](https://search.r-project.org/R/refmans/base/html/pipeOp.html) | Forward pipe operator introduced since R version 4.1.0 |
| [`~`](https://search.r-project.org/R/refmans/base/html/tilde.html) | Tilde operator, to separate the left- and right-hand sides in a `formula` |
| `.` | Dot symbol, to denote the remaining variables contained in a [`data.frame`](https://search.r-project.org/R/refmans/base/html/data.frame.html). See [`formula`](https://search.r-project.org/R/refmans/stats/html/formula.html) and [`terms.formula`](https://search.r-project.org/R/refmans/stats/html/terms.formula.html) for details. |
| [`:`](https://search.r-project.org/R/refmans/base/html/Colon.html) | Colon operator for [`interaction`](https://search.r-project.org/R/refmans/base/html/interaction.html) of [`factor`](https://search.r-project.org/R/refmans/base/html/factor.html)s, see section *Details* of [`formula`](https://search.r-project.org/R/refmans/stats/html/formula.html) documentation |
| `/` | Forward slash operator for nested grouping structure, see section *Details* of [`formula`](https://search.r-project.org/R/refmans/stats/html/formula.html) documentation |
| [`::`, `:::`](https://search.r-project.org/R/refmans/base/html/ns-dblcolon.html) | Double and triple colon operators, explicitly-[namespace](https://search.r-project.org/R/refmans/base/html/ns-reflect.html)d function or object |
| [`anylist`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/anylist.html) | List of objects of any type, from package **`spatstat.geom`** |
| [`attr`](https://search.r-project.org/R/refmans/base/html/attr.html), [`attributes`](https://search.r-project.org/R/refmans/base/html/attributes.html) | Attributes |
| [`body`](https://search.r-project.org/R/refmans/base/html/body.html) | Body of a [`function`](https://search.r-project.org/R/refmans/base/html/function.html) |
| [`cor`, `cov`, `cov2cor`](https://search.r-project.org/R/refmans/stats/html/cor.html) | Correlation matrix, variance-covariance matrix, and their conversion |
| [`cor.spatial`](https://search.r-project.org/CRAN/refmans/SpatialPack/html/cor.spatial.html) | TjÃ¸stheim's nonparametric correlation coefficient, from package **`SpatialPack`** [@SpatialPack] |
| [`data.frame`](https://search.r-project.org/R/refmans/base/html/data.frame.html) | Data frame |
| [`diag`](https://search.r-project.org/R/refmans/base/html/diag.html) | Matrix diagonals |
| [`dist`](https://search.r-project.org/R/refmans/stats/html/dist.html) | Distance matrix |
| [`ecdf`](https://search.r-project.org/R/refmans/stats/html/ecdf.html) | Empirical cumulative distribution function |
| [`environment`](https://search.r-project.org/R/refmans/base/html/environment.html), [`as.environment`](https://search.r-project.org/R/refmans/base/html/as.environment.html) | (Coerce to an) environment |
| [`eval`](https://search.r-project.org/R/refmans/base/html/eval.html) | Evaluate an R `expression` |
| [`export`](https://cran.r-project.org/web/packages/roxygen2/vignettes/namespace.html) | Export tags in [NAMESPACE](https://bookdown.dongzhuoer.com/hadley/r-pkgs/namespace) |
| [`expression`](https://search.r-project.org/R/refmans/base/html/expression.html) | Unevaluated expressions |
| [`factor`](https://search.r-project.org/R/refmans/base/html/factor.html) | Categorical object, a.k.a., factor |
| [`file.size`](https://search.r-project.org/R/refmans/base/html/file.info.html) | File size in bytes |
| (one-sided) [`formula`](https://search.r-project.org/R/refmans/stats/html/formula.html) | Formula, or [one-sided formula](https://search.r-project.org/R/refmans/stats/html/asOneSidedFormula.html) |
| `foobar` | Placeholder; <https://en.wikipedia.org/wiki/Foobar> |
| [`formals`](https://search.r-project.org/R/refmans/base/html/formals.html) | Formal arguments of R function |
| [`function`](https://search.r-project.org/R/refmans/base/html/function.html) | R function definition |
| [`fv`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/fv.html), [`fv.object`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/fv.object.html), [`plot.fv`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/plot.fv.html) | (Plot of) function value table, from package **`spatstat.explore`** |
| [`ggplot`](https://search.r-project.org/CRAN/refmans/ggplot2/html/ggplot.html) | Elegant data visualisations using the grammar-of-graphics, from package **`ggplot2`** [@ggplot2] |
| [`global_envelope_test`](https://search.r-project.org/CRAN/refmans/GET/html/global_envelope_test.html) | Global envelope test, from package **`GET`** [@GET] |
| [`groupedHyperframe`](https://CRAN.R-project.org/package=groupedHyperframe) | Grouped hyper data frame |
| `hypercolumns`, [`hyperframe`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/hyperframe.html) | (Hyper columns of) hyper data frame, from package **`spatstat.geom`** |
| [`identical`](https://search.r-project.org/R/refmans/base/html/identical.html) | Exact equality in R |
| [`im`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/im.html) | Pixel image object, from package **`spatstat.geom`** |
| [`inherits`](https://search.r-project.org/R/refmans/base/html/class.html) | Class inheritance |
| [`Inf`, `is.finite`](https://search.r-project.org/R/refmans/base/html/is.finite.html) | Positive infinity $\infty$ |
| [`kable`](https://search.r-project.org/CRAN/refmans/knitr/html/kable.html) | Tables in LaTeX, HTML, markdown and reStructuredText, from package **`knitr`** [@knitr] |
| `kerndens` | Kernel [`density`](https://search.r-project.org/R/refmans/stats/html/density.html), `stats::density.default()$y` |
| [`kmeans`](https://search.r-project.org/R/refmans/stats/html/kmeans.html) | $k$-means clustering [@kmeans] |
| [`language`](https://search.r-project.org/R/refmans/base/html/is.language.html) | R language object |
| [`length`](https://search.r-project.org/R/refmans/base/html/length.html) | Length of an object |
| [`lengths`](https://search.r-project.org/R/refmans/base/html/lengths.html) | Lengths of `list` or `vector` elements |
| [`library`](https://search.r-project.org/R/refmans/base/html/library.html) | Loading/attaching packages |
| [`list`](https://search.r-project.org/R/refmans/base/html/list.html), [`listof`](https://search.r-project.org/R/refmans/stats/html/listof.html) | Lists of objects |
| [`list2env`](https://search.r-project.org/R/refmans/stats/html/list2env.html) | Create an `environment` containing all `list` components as objects |
| [`log`, `log1p`, `log2`, `log10`](https://search.r-project.org/R/refmans/base/html/Log.html) | $\log(x)$ and $\log(x+1)$ transformations |
| [`.Machine`](https://search.r-project.org/R/refmans/base/html/zMachine.html) | Numerical characteristics of the machine R is running on, e.g., 32-bit integers and IEC 60559 floating-point (double precision) arithmetic |
| [`markformat`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/spatstat.geom-internal.html) | Storage mode of `marks`, from package **`spatstat.geom`** |
| [`marks`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/spatstat.geom-internal.html), [`is.marked`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/is.marked.html) | Marks of a point pattern, from package **`spatstat.geom`** |
| [`match`](https://search.r-project.org/R/refmans/base/html/match.html) | Value matching |
| [`matrix`](https://search.r-project.org/R/refmans/base/html/matrix.html) | Matrices |
| [`merge`, `merge.data.frame`](https://search.r-project.org/R/refmans/base/html/merge.html) | Merge two `data.frame`s |
| [`mc.cores`](https://search.r-project.org/R/refmans/parallel/html/mclapply.html) | Number of central processing unit (CPU) cores to use for parallel computing |
| [`message`](https://search.r-project.org/R/refmans/base/html/message.html) | Diagnostic message printed in R console |
| [`missing`](https://search.r-project.org/R/refmans/base/html/missing.html) | R [`function`](https://search.r-project.org/R/refmans/base/html/function.html) not having a default value for a [`formals`](https://search.r-project.org/R/refmans/base/html/formals.html) argument |
| [`multitype`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/spatstat.geom-internal.html) | Multitype spatial object, from package **`spatstat.geom`** |
| [`NaN`](https://search.r-project.org/R/refmans/base/html/is.finite.html) | Not-a-Number |
| [`na.fail`, `na.omit`, `na.exclude`, `na.pass`](https://search.r-project.org/R/refmans/stats/html/na.fail.html) | Handle missing values in R objects |
| [`names`](https://search.r-project.org/R/refmans/base/html/names.html) | Names of an R object |
| [`ncol`, `nrow`](https://search.r-project.org/R/refmans/base/html/nrow.html) | Number of rows/columns of an [`array`](https://search.r-project.org/R/refmans/base/html/array.html) |
| [`npoints`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/npoints.html) | Number of points in a point pattern, from package **`spatstat.geom`** |
| [`numeric`](https://search.r-project.org/R/refmans/base/html/numeric.html) | numeric, i.e., [`double`](https://search.r-project.org/R/refmans/base/html/double.html)-precision object |
| [`object.size`](https://search.r-project.org/R/refmans/utils/html/object.size.html) | Memory allocation |
| [`pi`](https://search.r-project.org/R/refmans/base/html/Constants.html) | Mathematical constant $\pi$ |
| `pmean`, `pmedian` | Point-wise mean and median, from package `groupedHyperframe` |
| [`pmax`, `pmin`](https://search.r-project.org/R/refmans/base/html/Extremes.html) | Point-wise maxima and minima |
| [`ppp`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/ppp.html), [`ppp.object`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/ppp.object.html) | (Marked) point pattern, from package **`spatstat.geom`** |
| `ppplist` | List of [`ppp.object`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/ppp.object.html)s, which inherits from [`solist`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/solist.html), from package **`spatstat.geom`** |
| [`quantile`](https://search.r-project.org/R/refmans/stats/html/quantile.html) | Quantile |
| [`range`](https://search.r-project.org/R/refmans/base/html/range.html) | Range of values |
| [`rnorm`](https://search.r-project.org/R/refmans/stats/html/Normal.html) | Random number generator for [normal distribution](https://en.wikipedia.org/wiki/Normal_distribution) |
| [`rlnorm`](https://search.r-project.org/R/refmans/stats/html/Lognormal.html) | Random number generator for [log-normal distribution](https://en.wikipedia.org/wiki/Log-normal_distribution) |
| `S3`, `generic`, [`UseMethod`](https://search.r-project.org/R/refmans/base/html/UseMethod.html), [`methods`](https://search.r-project.org/R/refmans/utils/html/methods.html), [`getS3method`](https://search.r-project.org/R/refmans/utils/html/getS3method.html) | `S3` object oriented system, <https://adv-r.hadley.nz/s3.html> |
| `S4`, [`isS4`](https://search.r-project.org/R/refmans/base/html/isS4.html), [`setClass`](https://search.r-project.org/R/refmans/methods/html/setClass.html), [`setGeneric`](https://search.r-project.org/R/refmans/methods/html/setGeneric.html), [`setMethod`](https://search.r-project.org/R/refmans/methods/html/setMethod.html), [`getMethod`](https://search.r-project.org/R/refmans/methods/html/getMethod.html) | `S4` object oriented system, <https://adv-r.hadley.nz/s4.html>, implemented in package **`methods`** shipped with vanilla `r R.version.string` |
| `S7`, [`new_generic`](https://search.r-project.org/CRAN/refmans/S7/html/new_generic.html), [`method`](https://search.r-project.org/CRAN/refmans/S7/html/method.html) | `S7` object oriented system, a successor to `S3` and `S4`, <https://rconsortium.github.io/S7>, currently in package **`S7`** [@S7] |
| [`save`](https://search.r-project.org/R/refmans/base/html/save.html), [`saveRDS`](https://search.r-project.org/R/refmans/base/html/readRDS.html), `xz` | Save with [`xz`](https://en.wikipedia.org/wiki/XZ_Utils) compression |
| [`sd`](https://search.r-project.org/R/refmans/stats/html/sd.html) | Standard deviation |
| [`search`](https://search.r-project.org/R/refmans/base/html/search.html) | Search path |
| [`seq`, `seq.int`](https://search.r-project.org/R/refmans/base/html/search.html) | Sequence generation |
| [`signature`](https://search.r-project.org/R/refmans/methods/html/GenericFunctions.html) | Tools for managing `S4` generic functions |
| [`solist`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/solist.html) | List of two-dimensional spatial objects, from package **`spatstat.geom`** |
| [`split`](https://search.r-project.org/R/refmans/base/html/split.html) | Divide into groups |
| [`stopifnot`](https://search.r-project.org/R/refmans/base/html/stopifnot.html) | To ensure the truth of R [`expression`](https://search.r-project.org/R/refmans/base/html/expression.html)s |
| [`Surv`](https://search.r-project.org/CRAN/refmans/survival/html/Surv.html) | Survival, i.e., time-to-event, object, from package **`survival`** [@survival] |
| [`symbol`, `name`](https://search.r-project.org/R/refmans/base/html/name.html) | R object name/symbol |
| [`t`, `t.default`](https://search.r-project.org/R/refmans/base/html/t.html) | Transpose |
| [`tempfile`](https://search.r-project.org/R/refmans/base/html/tempfile.html) | Create names for temporary files |
| [`trapz`, `cumtrapz`](https://search.r-project.org/CRAN/refmans/pracma/html/trapz.html) | (Cumulative) [trapezoidal integration](https://en.wikipedia.org/wiki/Trapezoidal_rule), from package **`pracma`** [@pracma] |
| [`typeof`](https://search.r-project.org/R/refmans/base/html/typeof.html) | R internal type or storage mode of any object |
| [`unclass`](https://search.r-project.org/R/refmans/base/html/class.html) | Remove `S3` `'class'` attribute |
| [`vector`](https://search.r-project.org/R/refmans/base/html/vector.html) | Vector |
| [`with`, `with.default`](https://search.r-project.org/R/refmans/base/html/with.html), [`with.hyperframe`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/with.hyperframe.html) | To `eval`uate an `expression` in a local `environment`, or in *each row* of a `hyperframe` |
| [`within`, `within.data.frame`](https://search.r-project.org/R/refmans/base/html/with.html) | To `eval`uate an `expression` in a local `environment` and makes modifications to the `environment` |

: Terms & Abbreviations in R {#tbl-Rterm}

{{< pagebreak >}}

# Index of Topics

@tbl-index summarizes the topics covered in this vignette, and where to find them.

| Topic | Where to Find |
|:-----------------------------------|:-----------------------------------|
| `fvlist` | @sec-fvlist |
| `fv.object` | @sec-fv |
| `groupedHyperframe` | @sec-groupedHyperframe, @sec-groupedHyperframe-appendix |
| `hyperframe` | @sec-hyperframe, @sec-dont-hyperframe |
| `ppplist` | @sec-ppplist |
| `ppp.object` | @sec-ppp, @sec-dont-ppp |
| `solist` | @sec-solist, @sec-dont-solist |
| $k$-means clustering | @sec-kmeans |
| $r_\text{max}$, default | @sec-default_rmax, @sec-ppplist, @sec-default_rmax-hyperframe |
| $r_\text{max}$, legal | @sec-legal_rmax |
| split by $k$-means clustering | @sec-split_kmeans, @sec-ppplist, @sec-split_kmeans-hyperframe |
| trapezoidal integration | @sec-trapz |

: Index of Topics {#tbl-index}

# References

::: {#refs}
:::
