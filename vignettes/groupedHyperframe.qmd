---
title: "Grouped Hyper Data Frame"
author: Tingting Zhan
date: "`r format(Sys.time(), 'Last updated %d %B, %Y')`"
format: 
  html:
    page-layout: full
    html-math-method: katex
number-sections: true
toc: true
toc-location: left
toc-depth: 4
toc-title: ''
editor: source
bibliography: groupedHyperframe.bib
knitr:
  opts_chunk: 
    collapse: true
    comment: "#" 
vignette: >
  %\VignetteIndexEntry{intro}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

```{=html}
<!--
`r knitr::asis_output('\U1f5dd')`
seems not needed
-->
```

# Introduction

This vignette of R package **`groupedHyperframe`** ([CRAN](https://cran.r-project.org/package=groupedHyperframe), [Github](https://github.com/tingtingzhan/groupedHyperframe), [RPubs](https://rpubs.com/tingtingzhan/groupedHyperframe)) documents

-   the creation of `groupedHyperframe` object,
-   the batch processes for a `hyperframe` and/or `groupedHyperframe`, and
-   the aggregation of various statistics over (nested) grouping structure.

R terminology might be different from that of mathematics and statistics. Please refer to @sec-Rterms for explanation and reference of the terms and abbreviations used in this vignette.

Package **`groupedHyperframe`** `Enhances` the **`spatstat.*`** family of packages [@spatstat15; @spatstat05], specifically

-   **`spatstat.explore`** (dev v`r packageVersion('spatstat.explore')`), with
    -   new methods for `fv.object`
    -   batch processes to return a hypercolumn of `fv.object`s
-   **`spatstat.geom`** (dev v`r packageVersion('spatstat.geom')`), with
    -   a new derived class of `hyperframe`
    -   new methods for `ppp.object` and `hyperframe`

Package **`groupedHyperframe`** `Imports` packages

-   **`cli`** [@cli, v`r packageVersion('cli')`], for attractive command line interfaces
-   `r '\U1f5dd'` **`GET`** [@GET, v`r packageVersion('GET')`], key dependency, for global envelope test
-   **`ggplot2`** [@ggplot2, v`r packageVersion('ggplot2')`], **`geomtextpath`** [@geomtextpath, v`r packageVersion('geomtextpath')`], for educational visualization
-   `r '\U1f5dd'` **`matrixStats`** [@matrixStats, v`r packageVersion('matrixStats')`], key dependency, for matrix arithmetic
-   **`parallel`** shipped with `r R.version$version.string`, for parallel computing
-   `r '\U1f5dd'` **`pracma`** [@pracma, v`r packageVersion('pracma')`], key dependency, for (cumulative) trapezoidal integration
-   `r '\U1f5dd'` **`SpatialPack`** [@SpatialPack, v`r packageVersion('SpatialPack')`], key dependency, for Tj√∏stheim's coefficient of spatial association
-   `r '\U1f5dd'` **`spatstat.explore`** (dev v`r packageVersion('spatstat.explore')`), **`spatstat.geom`** (dev v`r packageVersion('spatstat.geom')`), **`spatstat.random`** (dev v`r packageVersion('spatstat.random')`), key dependency, for spatial statistics

Package **`groupedHyperframe`** `Suggests` packages

-   **`patchwork`** [@patchwork v`r packageVersion('patchwork')`], for collage of `ggplot`s
-   `r '\U1f5dd'` **`spatstat.data`** (dev v`r packageVersion('spatstat.data')`), key suggest, for example spatial data set
-   `r '\U1f5dd'` **`survival`** [@survival, v`r packageVersion('survival')`], key suggest, <!--for function `survival:::as.data.frame.Surv()`--> to help `hyperframe` understand `Surv` object

## Prerequisite

### Environment

Package **`groupedHyperframe`** requires R version 4.5.0 (released 2025-04-11) or higher ([macOS](https://cran.r-project.org/bin/macosx/), [Windows](https://cran.r-project.org/bin/windows/base/)). An Integrated Development Environment (IDE), e.g., [RStudio](https://posit.co/download/rstudio-desktop/) [@RStudio] or [Positron](https://positron.posit.co/download.html), is not required, but highly recommended. This vignette is created under `r R.version$version.string` using packages **`knitr`** [@knitr, v`r packageVersion('knitr')`], **`quarto`** [@quarto, v`r packageVersion('quarto')` with [Quarto](https://quarto.org/docs/get-started/) v`r quarto::quarto_version()`] and **`rmarkdown`** [@rmarkdown, v`r packageVersion('rmarkdown')`].

```{r}
#| code-fold: true
#| code-summary: "Environment on author's computer"
#| label: author-env
Sys.info()[c('sysname', 'release', 'machine')]
R.version
```

### **`spatstat.*`** Family

Package **`groupedHyperframe`** requires the development versions of the **`spatstat.*`** family of packages.

```{r}
#| eval: false
remotes::install_github('spatstat/spatstat', upgrade = 'always')
remotes::install_github('spatstat/spatstat.data', upgrade = 'always')
remotes::install_github('spatstat/spatstat.explore', upgrade = 'always')
remotes::install_github('spatstat/spatstat.geom', upgrade = 'always')
remotes::install_github('spatstat/spatstat.linnet', upgrade = 'always')
remotes::install_github('spatstat/spatstat.model', upgrade = 'always')
remotes::install_github('spatstat/spatstat.random', upgrade = 'always')
remotes::install_github('spatstat/spatstat.sparse', upgrade = 'always')
remotes::install_github('spatstat/spatstat.univar', upgrade = 'always')
remotes::install_github('spatstat/spatstat.utils', upgrade = 'always')
```

```{r}
#| label: dev_spatstat
#| code-fold: true
#| code-summary: 'Developer version of **`spatstat.*`** family ahead of CRAN'
spatstat = c(
  'spatstat', 'spatstat.data', 'spatstat.explore', 'spatstat.geom', 'spatstat.linnet', 
  'spatstat.model', 'spatstat.random', 'spatstat.sparse', 'spatstat.univar', 'spatstat.utils'
)
cran = available.packages(contriburl = 'https://cran.rstudio.com/src/contrib') |> 
  as.data.frame.matrix() |>
  subset.data.frame(subset = Package %in% spatstat, select = c('Package', 'Version')) |> 
  within.data.frame(expr = {
    `on CRAN` = Version; Version = NULL
  })
github = installed.packages() |>
  as.data.frame.matrix() |>
  subset.data.frame(subset = Package %in% spatstat, select = c('Package', 'Version')) |> 
  within.data.frame(expr = {
    `on GitHub` = Version; Version = NULL
  })
merge.data.frame(cran, github, by = 'Package') |> 
  subset.data.frame(subset = `on CRAN` != `on GitHub`) |>
  within.data.frame(expr = {
    Package = Package |> sprintf(fmt = '**`%s`**')
  }) |>
  knitr::kable(
    row.names = FALSE,
    label = 'tbl-dev_spatstat', 
    caption = Sys.Date() |> format() |> 
      sprintf(fmt = 'Developer version of `spatstat.*` family ahead of CRAN, as of %s'))
```

### Package **`groupedHyperframe`**

Experimental (and maybe unstable) features of package **`groupedHyperframe`** are released *extremely frequently* to [Github](https://github.com/tingtingzhan/groupedHyperframe). [Active developers should use the Github version; suggestions and bug reports are welcome!]{style="background-color: #FFFF00"} Stable releases to [CRAN](https://CRAN.R-project.org/package=groupedHyperframe) are typically updated every 2 to 3 months, or when the authors have an upcoming manuscript in the peer-reviewing process.

```{r}
#| eval: false
remotes::install_github('tingtingzhan/groupedHyperframe')
```

```{r}
#| eval: false
#| code-fold: true
#| code-summary: "Developers, do NOT use the CRAN version!"
utils::install.packages('groupedHyperframe') # Developers, do NOT use!!
```

## Getting Started

Examples in this vignette require that the `search` path has

```{r}
#| message: false
#| label: search
library(groupedHyperframe)
library(survival) # to help hyperframe understand Surv object
```

```{r}
#| echo: false
#| label: cran
op = par(no.readonly = TRUE)
#options(mc.cores = 1L) # for CRAN submission
```

## Acknowledgement

This work is supported by National Institutes of Health, U.S. Department of Health and Human Services grants

-   R01CA222847 ([I. Chervoneva](https://orcid.org/0000-0002-9104-4505), [T. Zhan](https://orcid.org/0000-0001-9971-4844), and [H. Rui](https://orcid.org/0000-0002-8778-261X))
-   R01CA253977 (H. Rui and I. Chervoneva).

{{< pagebreak >}}

# Grouped Hyper Data Frame {#sec-groupedHyperframe}

An `S3` class `hyperframe`, for **hyper data frame**, is defined in package **`spatstat.geom`**. A `hyperframe` contains columns either as `vector`s like in a `data.frame`, or as `list`s of objects of the same class, a.k.a., the `hypercolumns`. The `hyperframe` data structure is particularly useful in spatial analysis, e.g., with medical images, where the spatial information in each image would be represented by one element in a hypercolumn. For example, example data *`demohyper`* from package **`spatstat.data`** contains a `factor` column *`Group`*, a point-pattern `ppp`-hypercolumn *`Points`*, and a pixel image `im`-hypercolumn *`Image`*. Several `S3` method dispatches to the `hyperframe` class behave *very differently* from their counterpart in vanilla R (Appendix @sec-hyperframe-appendix).

```{r}
spatstat.data::demohyper
```

We introduce a new `S3` class `groupedHyperframe`, for **grouped hyper data frame**, which `inherits` from the `hyperframe` class. The derived class `groupedHyperframe` has additional `attributes`

-   `attr(., 'group')`, a one-sided `formula` of the (nested) grouping structure, e.g., *`~patient/image`* when each patient has one or more images. Appendix @sec-nestedGroup provides references to the grammar of the nested grouping structure $g_1/.../g_m$ (`~g1/.../gm`).

The `S3` generic function `as.groupedHyperframe()` converts objects of various classes into a `groupedHyperframe`.

We have a toy data example *`wrobel_lung`* in package **`groupedHyperframe`** originally from Dr. [Julia Wrobel](https://sph.emory.edu/profile/faculty/julia-wrobel). Consider a subset *`wrobel_lung0`* with the only non-identical column *`hladr`* in the lowest group *`image_id`* of the nested grouping structure *`~patient_id/image_id`*.

```{r}
#| label: wrobel_lung0
wrobel_lung0 = wrobel_lung |>
  within.data.frame(expr = {
    x = y = NULL
    dapi = phenotype = tissue = NULL
    stage_numeric = pack_years = adjuvant_therapy = NULL # to save console space
  })
```

```{r}
#| code-fold: true
#| code-summary: 'A `data.frame` object *`wrobel_lung0`*'
wrobel_lung0 |> 
  head()
```

The `S3` method dispatch `as.groupedHyperframe.data.frame()` converts a `data.frame`, e.g., *`wrobel_lung0`*, with substantial amount of duplicated information into a `groupedHyperframe`. This function

1.  inspects the input `data.frame` by the user-specified (nested) `group`ing structure, e.g., *`~patient_id/image_id`*;
2.  identifies the `data.frame` column(s), e.g., the numeric column *`wrobel_lung0$hladr`*, with *non-identical elements* within the lowest group, and converts them into the hypercolumn(s) of the output `groupedHyperframe`, e.g., *`wrobel_lung0g$hladr`*. Each row of a `groupedHyperframe` represents the lowest group of the nested grouping structure.

```{r}
#| label: wrobel_lung0g
wrobel_lung0g = wrobel_lung0 |> 
  as.groupedHyperframe(group = ~ patient_id/image_id)
```

Another `S3` method dispatch `as.groupedHyperframe.hyperframe()` is discussed in Appendix @sec-asgroupedHyperframe-hyperframe.

The `S3` method dispatch `print.groupedHyperframe()` highlights the nested grouping structure, number of clusters at each grouping level, as well as the first 10 (or less) rows of the input.

```{r}
wrobel_lung0g
```

Converting a `data.frame` with substantial amount of duplicated information into a `groupedHyperframe` greatly reduces the memory allocation. A `groupedHyperframe`, however, would not reduce much the `save`d `file.size` compared to a `data.frame`, if `xz` compression is used for both.

```{r}
#| code-fold: true
#| code-summary: "Reducing memory allocation"
#| label: object-size
unclass(object.size(wrobel_lung0g) / object.size(wrobel_lung0))
```

```{r}
#| code-fold: true
#| code-summary: "Not reducing `xz`-compressed file size"
#| label: xz
f_g = tempfile(fileext = '.rds')
wrobel_lung0g |> saveRDS(file = f_g, compress = 'xz')
f = tempfile(fileext = '.rds')
wrobel_lung0 |> saveRDS(file = f, compress = 'xz')
file.size(f_g) / file.size(f)
```

Functions `aggregate_*()` aggregates the hypercolumns in a `groupedHyperframe` at either one of the nested grouping levels $g_1,\cdots,g_{m-1}$. Aggregation at the lowest grouping level $g_m$ is ignored, i.e., no aggregation to be performed. Available aggregation methods are the point-wise minima `base::pmin()`, maxima `base::pmax()`, means `pmean()` (default) and medians `pmedian()`.

Function `aggregate_quantile()` aggregates the `quantile`s of each element in the numeric-hypercolumn, e.g., *`hladr`* in *`wrobel_lung0g`*, by point-wise means (default of parameter `f_aggr_`) at the biologically independent group, e.g., *`~patient_id`*. The returned object is a `hyperframe` instead of a `groupedHyperframe`, as we have *one* aggregated *`hladr.quantile`* per *`~patient_id`*, thus eliminates the need for a grouping structure. The R console output is taken care of by the `S3` method dispatch `spatstat.geom::print.hyperframe()`.

```{r}
#| message: false
wrobel_lung0g |>
  aggregate_quantile(by = ~ patient_id, probs = seq.int(from = .01, to = .99, by = .01))
```

{{< pagebreak >}}

# Grouping `ppp`-Hypercolumn

In this section, we first introduce the creation of a `groupedHyperframe` with *one-and-only-one* point pattern (`ppp`) hypercolumn. Then, we discuss

-   the batch processes of spatial point pattern analyses on the *one-and-only-one* `ppp`-hypercolumn of a `hyperframe` (and/or `groupedHyperframe`). These batch processes are not intended for a `hyperframe` (and/or `groupedHyperframe`) with multiple `ppp`-hypercolumns in the foreseeable future, as that would require checking for name clashes in the `marks` from multiple `ppp`-hypercolumns.
-   the aggregation of batch-process-returns over the nested grouping structure.

Function `grouped_ppp()` creates a `groupedHyperframe` with *one-and-only-one* `ppp`-hypercolumn. In the following example, the argument `formula` takes form of `<marks> ~ <variable.of.interest> | <group>`, specifically,

-   the point pattern `marks`, e.g., numeric mark *`hladr`* and `multitype` mark *`phenotype`*, on the left-hand-side
-   the additional predictors and/or endpoints for downstream analysis, e.g., *`OS`*, *`gender`* and *`age`*, before the `|` separator on the right-hand-side. Alternatively, user may use the dot symbol `.` to denote the remaining variables except for those mentioned in the `marks` and the nested grouping structure.
-   the (nested) grouping structure, e.g., *`image_id`* nested in *`patient_id`*, after the `|` separator on the right-hand-side.

```{r}
s = wrobel_lung |>
   grouped_ppp(formula = hladr + phenotype ~ OS + gender + age | patient_id/image_id)
```

```{r}
#| code-fold: true
#| code-summary: Alternatively, use dot symbol `.` for additional predictors and/or endpoints
wrobel_lung |>
   grouped_ppp(formula = hladr + phenotype ~ . | patient_id/image_id)
```

The `S3` method dispatch `print.groupedHyperframe()` highlights the nested grouping structure, number of clusters at each grouping level, as well as the first 10 (or less) rows of the `groupedHyperframe`.

```{r}
s
```

## Batch processes {#sec-batch}

### Return of `fv`-hypercolumn

In this section, we discuss the batch processes that return a function value table (`fv`) hypercolumn, i.e., a hypercolumn which consists of a `list` of `fv.object`s.

| Batch Process | Workhorse in package **`spatstat.explore`** | `fv`-hypercolumns Suffix |
|------------------------|------------------------|------------------------|
| `Emark_()` and `Vmark_()` | [`Emark` and `Vmark`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Emark.html), conditional mean $E(r)$ and variance $V(r)$, diagnostics for dependence between the points and the marks [@Emark] | `.E` and `.V` |
| `markcorr_()` | [`markcorr`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/markcorr.html), marked correlation $k_{mm}(r)$ or generalized mark correlation $k_f(r)$ [@markcorr] | `.k` |
| `markvario_()` | [`markvario`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/markvario.html), mark variogram $\gamma(r)$ [@markvario] | `.gamma` |
| `Kmark_()` | [`Kmark`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Kmark.html), mark-weighted $K_f(r)$ function [@Kmark] | `.K` |

: Batch processes applicable to numeric `marks`

| Batch Process | Workhorse in package **`spatstat.explore`** | `fv`-hypercolumns Suffix |
|------------------------|------------------------|------------------------|
| `Gcross_()` | [`Gcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Gcross.html), multitype nearest-neighbour distance $G_{ij}(r)$ | `.G` |
| `Kcross_()` | [`Kcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Kcross.html), multitype $K_{ij}(r)$ | `.K` |
| `Jcross_()` | [`Jcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Jcross.html), multitype $J_{ij}(r)$ [@Jcross] | `.J` |
| `Lcross_()` | [`Lcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Lcross.html), multitype $L_{ij}(r)=\sqrt{\frac{K_{ij}(r)}{\pi}}$ | `.L` |

: Batch processes applicable to `multitype` `marks`

### Return of numeric-hypercolumn

In this section, we discuss the batch processes that return a numeric hypercolumn, i.e., a hypercolumn which consists of a `list` of numeric `vector`s.

| Batch Process | Workhorse in package **`spatstat.geom`** | Applicable to | numeric-hypercolumns Suffix |
|------------------|------------------|------------------|------------------|
| `nncross_()` | [`nncross.ppp`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/nncross.html)`(., what = 'dist')`, nearest neighbour distance | `multitype` marks | `.nncross` |

### In a pipeline

Multiple batch processes may be applied to a `hyperframe` (and/or `groupedHyperframe`) in a pipeline using the native pipe operator `|>` introduced since R version 4.1.0.

```{r}
r = seq.int(from = 0, to = 250, by = 10)
out = s |>
  Emark_(r = r, correction = 'none') |> # slow
  # Vmark_(r = r, correction = 'none') |> # slow
  # markcorr_(r = r, correction = 'none') |> # slow
  # markvario_(r = r, correction = 'none') |> # slow
  # Kmark_(r = r, correction = 'none') |> # fast
  Gcross_(i = 'CK+.CD8-', j = 'CK-.CD8+', r = r, correction = 'none') |> # fast
  # Kcross_(i = 'CK+.CD8-', j = 'CK-.CD8+', r = r, correction = 'none') |> # fast
  nncross_(i = 'CK+.CD8-', j = 'CK-.CD8+', correction = 'none') # fast
```

The `message` of "Legal $r_\text{max}$" provides the indices in the `ppp`-hypercolumn, i.e., the row indices of the `hyperframe`, where the legal $r_\text{max}$ (Appendix @sec-legal_rmax) is smalller than the user-specified $r_\text{max}$. The returned `hyperframe` (and/or `groupedHyperframe`) has

-   `fv`-hypercolumn *`hladr.E`*, created by function `Emark_()` on numeric mark *`hladr`*
-   `fv`-hypercolumn *`phenotype.G`*, created by function `Gcross_()` on `multitype` mark *`phenotype`*
-   numeric-hypercolumn *`phenotype.nncross`*, created by function `nncross_()` on `multitype` mark *`phenotype`*

```{r}
out
```

## Truncated Aggregation

In this section, we discuss the aggregation over nested grouping structure.

### Of `fv`-hypercolumn(s)

Function `aggregate_fv()` performs (truncated) aggregation of

-   *`<mark>.<fv>.value`*, the *function values*, i.e., the black-solid-curve (Appendix @sec-blackSolidCurve) determined by function `spatstat.explore::plot.fv()`
-   *`<mark>.<fv>.cumtrapz`*, the *cumulative trapezoidal integration* (Appendix @sec-trapz) under the black-solid-curve
-   *`<mark>.<fv>.cumvtrapz`*, the *cumulative average vertical height of trapezoidal integration* (Appendix @sec-vtrapz) under the black-solid-curve

When a user-specified $r_\text{max}$ is provided to a batch process (in @sec-batch) on *all* `ppp.object`s in the `ppp`-hypercolumn, inevitably some of the `fv`-returns may contain exceptional/illegal function values (Appendix @sec-legal_rmax). In this case, the aggregation is *truncated* at the minimum legal $r_\text{max}$ of the `fv.object`s in each `fv`-hypercolumn.

In the following example, we have

-   numeric-hypercolumns *`hladr.E.value`*, *`hladr.E.cumtrapz`* and *`hladr.E.cumvtrapz`* from `fv`-hypercolumns *`hladr.E`*. Function values from all `fv.object`s in the `fv`-hypercolumns *`hladr.E`* are legal, therefore, this aggregation is not truncated.

-   numeric-hypercolumns *`phenotype.G.value`*, *`phenotype.G.cumtrapz`* and *`phenotype.G.cumvtrapz`* from `fv`-hypercolumns *`phenotype.G`*. This aggregation is *truncated* at the minimum legal $r_\text{max}=240$ of the `fv.object`s in the `fv`-hypercolumn *`phenotype.G`*.

```{r}
(afv = out |>
  aggregate_fv(by = ~ patient_id, f_aggr_ = pmean))
```

User may specify an $r_\text{max}$ for truncation using the argument `rmax` of function `aggregate_fv()`.

```{r}
#| results: hide
out |>
  aggregate_fv(by = ~ patient_id, f_aggr_ = pmean, rmax = 220)
```

If the user-specified $r_\text{max}$ is greater than the minimum legal $r_\text{max}$, the user's $r_\text{max}$ will be ignored.

```{r}
#| results: hide
out |>
  aggregate_fv(by = ~ patient_id, f_aggr_ = pmean, rmax = 260)
```

In `hyperframe` *`afv`*, each one of the numeric-hypercolumns contains tabulated values on the common grid of $r$. One "slice" of the hypercolumn *`hladr.E.cumvtrapz`* at $r=50$ may be extracted by calling the `S3` method dispatch `spatstat.geom::with.hyperframe()` (which behaves *very differently* from function `base::with.default()`, Appendix @sec-hyperframe-appendix),

```{r}
E_r50_a = afv |>
  with(expr = {
    hladr.E.cumvtrapz['50']
  })
E_r50_a
```

Alternatively, the 5th slice (which corresponds to $r=50$, as the cumulative trapzoidal integration starts at $r=10$ instead of $r=0$) of the hypercolumn *`hladr.E.cumvtrapz`* may be extracted by

```{r}
E_r50_b = afv |>
  with(expr = {
    hladr.E.cumvtrapz[5L]
  })
E_r50_b
stopifnot(identical(E_r50_a, E_r50_b))
```

Developers may use the `S3` method dispatch `t.vectorlist()` in Appendix @sec-vectorlist.

```{r}
tE = afv$hladr.E.cumvtrapz |>
  t.vectorlist()
stopifnot(identical(E_r50_a, tE[[5L]]))
```

### Of numeric-hypercolumn, and numeric marks in `ppp`-hypercolumn

#### On `quantile`s

Function `aggregate_quantile()` aggregates the `quantile`s of the numeric-hypercolumns and the numeric marks in the `ppp`-hypercolumn. In the following example, we have

-   numeric-hypercolumn *`phenotype.nncross.quantile`*, the aggregated `quantile`s of numeric-hypercolumn *`phenotype.nncross`*.
-   numeric-hypercolumn *`hladr.quantile`*, the aggregated `quantile`s of numeric mark *`hladr`* in `ppp`-hypercolumn.

```{r}
#| message: false
out |>
  aggregate_quantile(by = ~ patient_id, probs = seq.int(from = 0, to = 1, by = .1))
```

#### On kernel densities

Function `aggregate_kerndens()` aggregates the kernel density of the numeric-hypercolumns and the numeric marks in the `ppp`-hypercolumn.

In the following example, we have

-   numeric-hypercolumn *`phenotype.nncross.kerndens`*, the aggregated kernel densities of numeric-hypercolumn *`phenotype.nncross`*.
-   numeric-hypercolumn *`hladr.kerndens`*, the aggregated kernel densities of numeric mark *`hladr`* in `ppp`-hypercolumn.

```{r}
#| message: false
(mdist = out$phenotype.nncross |> unlist() |> max())
out |> 
  aggregate_kerndens(by = ~ patient_id, from = 0, to = mdist)
```

{{< pagebreak >}}

# Peer-Reviewed Publications

Package **`groupedHyperframe`** plays a pivotal role in these peer reviewed publications from the authors.

## @Zhan25

> `r citation(package = 'hyper.gam')[[1L]] |> format(style = 'text') |> gsub(pattern = '\n', replacement = ' ', x = _)`

<details>

<summary>[BibTeX](https://ctan.org/pkg/bibtex) and/or [BibLaTeX](https://ctan.org/pkg/biblatex) entries for [LaTeX](https://www.latex-project.org) users</summary>

```{r}
#| echo: false
#| comment: ''
c(
  citation(package = 'hyper.gam'),
  citation(package = 'groupedHyperframe')
) |> toBibtex()
```

</details>

as well as @Yi25; @Yi23a; @Yi23b, was featured with a non-spatial `hyperframe` *`Ki67q`* with a numeric-hypercolumn *`logKi67.quantile`*. Functions in the code-chunk below are explained in @sec-groupedHyperframe.

```{r}
Ki67q = groupedHyperframe::Ki67 |>
  within.data.frame(expr = {
    x = y = NULL # remove x- and y-coords for non-spacial application
  }) |>
  as.groupedHyperframe(group = ~ patientID/tissueID) |> 
  aggregate_quantile(by = ~ patientID, probs = seq.int(from = .01, to = .99, by = .01))
```

```{r}
#| message: false
#| code-fold: true
#| code-summary: 'A `hyperframe` object *`Ki67q`*: aggregated quantiles'
Ki67q |>
  head()
```

Users are encouraged to learn more about this application from package **`hyper.gam`** vignette ([RPubs](https://rpubs.com/tingtingzhan/hyper_gam), [CRAN](https://CRAN.R-project.org/package=hyper.gam/vignettes/applications.html)), section *Quantile Index*.

{{< pagebreak >}}

# Appendix

Technical details, as well as the minor and/or experimental features, are covered in the Appendix, in order not to interrupt the main narrative of this vignette.

All R code-chunks are folded in the Appendix, for ease of navigation. They are categorized as

-   **Data**, to create an R object for further operations.
-   **Review**, to demonstrate functions shipped with vanilla `r R.version.string`, or from other packages.
-   **Example**, to demonstrate functions from package **`groupedHyperframe`**.
-   **Advanced**, discussions for R experts.
-   **Figure**, to create a `ggplot`.
-   **Workaround**, to provide alternative solutions to a problem.

## On Trapezoidal Integration {#sec-trapz}

The [chained trapezoidal rule](https://en.wikipedia.org/wiki/Trapezoidal_rule) of approximating a definite integral is an ancient idea since the dawn of human civilization.

Let $\{x_k; k=0,\cdots,N\}$ be a partition of the real interval $[a,b]$ such that $a = x_0 < x_1 < \cdots < x_{N-1} < x_N = b$ and $\Delta x_k= x_k - x_{k-1}$ be the length of the $k$-th sub-interval, then the trapezoidal approximation of the integration

$$
\begin{split}
\int_a^b f(x)\,dx & \approx \sum_{k=1}^{N}{\dfrac{f(x_{k-1})+f(x_{k})}{2}}\Delta x_{k} \\
& = \left(\frac{f(x_0)}{2}+\sum _{k=1}^{N-1}f(x_{k})+\frac{f(x_N)}{2}\right)\Delta x, \quad\iff\ \forall k, \Delta x_{k}\equiv \Delta x
\end{split}
$$ {#eq-trapz}

Consider

```{r}
#| code-fold: true
#| code-summary: '**Data**: a toy example $(x_0,x_1,x_2,x_3,x_4,x_5)^t$ and $\\{y_k = f(x_k);k=0,1,\cdots,5\\}$'
#| label: trapz_toy
(x = seq.int(from = 10L, to = 20L, by = 2L))
set.seed(12); (y = rnorm(n = length(x), mean = 1, sd = .2))
```

Function `pracma::trapz()` calculates a trapezoidal integration (@eq-trapz), visualized in @fig-vtrapz(A).

```{r}
#| code-fold: true
#| code-summary: '**Review**: `pracma::trapz()`'
pracma::trapz(x, y)
```

In R nomenclature, the term "cumulative" indicates an inclusive [scan](https://en.wikipedia.org/wiki/Prefix_sum#Scan_higher_order_function), that

> The `i`th element of the output is the operation result of the first-`i`-elements of the input

Function `pracma::cumtrapz()` calculates a cumulative trapezoidal integration. Note that the first element of the output is always `0`, as a trapezoidal integration needs at least $\left(x_0, f(x_0)\right)$ and $\left(x_1, f(x_1)\right)$.

```{r}
#| code-fold: true
#| code-summary: '**Review**: `pracma::cumtrapz()`'
pracma::cumtrapz(x, y)
```

### Average Vertical Height {#sec-vtrapz}

We define the *average vertical height* of a trapezoidal integration as the trapezoid (@eq-trapz) divided by the length of $x$-domain $b-a$,

$$
\begin{split}
(b-a)^{-1}\displaystyle\int_a^b f(x)\,dx & \approx (b-a)^{-1} \sum_{k=1}^{N}{\dfrac{f(x_{k-1})+f(x_{k})}{2}}\Delta x_{k} \\
& = N^{-1}\left(\frac{f(x_0)}{2}+\sum _{k=1}^{N-1}f(x_{k})+\frac{f(x_N)}{2}\right), \quad\iff\ \forall k, \Delta x_{k}\equiv \Delta x
\end{split}
$$ {#eq-vtrapz}

Function `vtrapz()` calculates the average vertical height of a trapezoidal integration (@eq-vtrapz). The (tentative) prefix `v` indicates "vertical". The shaded rectangle in @fig-vtrapz(A) has the same area as the trapezoidal integration. Therefore, we define the vertical height of the shaded rectangle as the *average vertical height* of the trapezoidal integration.

```{r}
#| code-fold: true
#| code-summary: '**Example**: `vtrapz()`'
vtrapz(x, y)
```

Function `cumvtrapz()` calculates the cumulative average vertical height of a trapezoidal integration. If $\forall k$, $\Delta x_{k}\equiv \Delta x$, the output has,

-   the 1st element `NaN`, i.e., the result of `0` (trapzoidal integration) divided by `0` (length of $x$-domain).
-   the 2nd element $(f(x_0)+f(x_1))/2$
-   the $(i+1)$-th element $i^{-1}(f(x_0)/2+\sum_{k=1}^{i-1}f(x_k)+f(x_i)/2)$. Note that the R does *not* use [zero-based numbering](https://en.wikipedia.org/wiki/Zero-based_numbering); i.e., R `vector` indices start at `1L` instead of `0L`
-   the $(N+1)$-th and last element as (@eq-vtrapz)

```{r}
#| code-fold: true
#| code-summary: '**Example**: `cumvtrapz()`'
cumvtrapz(x, y)
```

@fig-vtrapz visualizes the concept of (cumulative) average vertical height of a trapezoidal integration with

(A) the toy example $(x_0,x_1,\cdots,x_5)^t$ and $(y_0,y_1,\cdots,y_5)^t$;
(B) the kernel `stats::density()`, using the elements `$x` and `$y`;
(C) the empirical cumulative distribution function `stats::ecdf()`, using the objects `x` and `y` in the enclosing `environment`;
(D) the conditional mean $E(r)$ between the points and the marks, from function `spatstat.explore::Emark()`, using the element `$r` and the `key1val` (Appendix @sec-blackSolidCurve). [Say some English]{style="background-color: #FFFF00"}
(E) the conditional variance $V(r)$ between the points and the marks, from function `spatstat.explore::Vmark()`, using the element `$r` and the `key1val` (Appendix @sec-blackSolidCurve). [Say some English]{style="background-color: #FFFF00"}

```{r}
#| code-fold: true
#| code-summary: "**Figure**: Panel (A), visualize `vtrapz` and `cumvtrapz` of a toy example"
fig_vtrapz_1 = visualize_vtrapz(x, y) + 
  ggplot2::labs(title = '(A). a toy example')
```

```{r}
#| code-fold: true
#| code-summary: "**Figure**: Panel (B), visualize `vtrapz` and `cumvtrapz` of `stats::density()`"  
set.seed(12); fig_vtrapz_2 = rnorm(n = 1e3L) |> density() |> visualize_vtrapz() + 
  ggplot2::labs(title = '(B). kernel density')
```

```{r}
#| code-fold: true
#| code-summary: "**Figure**: Panel (C), visualize `vtrapz` and `cumvtrapz` of `stats::ecdf()`"  
set.seed(27); fig_vtrapz_3 = rnorm(n = 1e3L) |> ecdf() |> visualize_vtrapz() + 
  ggplot2::labs(title = '(C). empirical distribution')
```

```{r}
#| code-fold: true
#| code-summary: "**Figure**: Panel (D), visualize `cumvtrapz` of `spatstat.explore::Emark()`"  
fig_vtrapz_4 = spatstat.data::spruces |>
  spatstat.explore::Emark() |>
  visualize_vtrapz(draw.v = FALSE, draw.rect = FALSE) +
  ggplot2::labs(title = '(D). spatstat.explore::Emark()')
```

```{r}
#| code-fold: true
#| code-summary: "**Figure**: Panel (E), visualize `cumvtrapz` of `spatstat.explore::Vmark()`"  
fig_vtrapz_5 = spatstat.data::spruces |>
  spatstat.explore::Vmark() |>
  visualize_vtrapz(draw.v = FALSE, draw.rect = FALSE) +
  ggplot2::labs(title = '(E). spatstat.explore::Vmark()')
```

```{r}
#| label: fig-vtrapz
#| warning: false
#| code-fold: true
#| code-summary: "**Figure**: Panels collaged, visualize `vtrapz` and `cumvtrapz`"  
#| fig-height: 7.5
#| fig-width: 10
#| fig-align: left
#| fig-cap: "(Cumulative) average vertical height"
library(patchwork)
(fig_vtrapz_1 + fig_vtrapz_2 + fig_vtrapz_3 + fig_vtrapz_4 + fig_vtrapz_5 +
  plot_layout(ncol = 2L)) & 
  ggplot2::theme_minimal()
```

## On `groupedHyperframe` {#sec-groupedHyperframe-appendix}

### Nested Grouping Structure {#sec-nestedGroup}

Details of the nested grouping structure $g_1/.../g_m$ (`~g1/.../gm`) is provided in section *Details* of [`stats::formula`](https://search.r-project.org/R/refmans/stats/html/formula.html) documentation.

The nested grouping structure `~g1/.../gm` is made well known by the parameter `random` of functions `nlme::lme()` and `nlme::nlme()`. In fact, the 'grouped' extension of a `hyperframe` is inspired by the class `'groupedData'` defined in package **`nlme`** [@nlme], which `inherits` from the class `'data.frame'`.

Package **`groupedHyperframe`** allows interaction terms using colon operator `:` in the grouping structure, e.g., `g1/g2a:g2b/g3a:g3b:g3c`. This feature is made possible because the colon operator `:` has higher priority than the forward slash `/` in R `formula`.

```{r}
#| code-fold: true
#| code-summary: "**Review**: colon operator `:` has higher priority than forward slash `/`"
quote(g1/g2a:g2b/g3a:g3b:g3c) |>
  as.list()
```

Function `get_nested()` breaks down a nested grouping structure by the forward slash `/`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: `get_nested()`'
quote(g1/g2/g3) |>
  get_nested()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: `get_nested()` with interaction terms'
quote(g1/g2a:g2b/g3a:g3b:g3c) |>
  get_nested()
```

The (nested) grouping structure `attr(., 'group')` of a `groupedHyperframe`

-   must denote the highest level using a `symbol` (e.g., `g1`)
-   may denote the lower levels using a `symbol` (e.g., `g2`) or an interaction-term (e.g., `g2a:g2b`)

## On `hyperframe` {#sec-hyperframe-appendix}

Function `spatstat.geom::hyperframe()` returns a `hyperframe`, i.e., an object with `S3` class `'hyperframe'`. In addition to

```{r}
#| message: false
#| code-fold: true
#| code-summary: "The `S3` method dispatches to class `'hyperframe'` defined in package **`spatstat.geom`**"
library(spatstat.geom)
methods(class = 'hyperframe') |> 
  attr(which = 'info', exact = TRUE) |>
  subset(subset = from == 'spatstat.geom')
```

Package **`groupedHyperframe`** implements

```{r}
#| message: false
#| code-fold: true
#| code-summary: "Additional `S3` method dispatches to class `'hyperframe'`"
library(spatstat.geom) # must! for S3 generic function `spatstat.geom::superimpose`
methods(class = 'hyperframe') |> 
  attr(which = 'info', exact = TRUE) |>
  subset(subset = from == 'groupedHyperframe') |>
  knitr::kable(label = 'tbl-S3_hyperframe', caption = '`S3` method dispatches to class `\'hyperframe\'`')
```

The authors plan [**not**]{style="background-color: #FFFF00"} to implement

-   an `S3` method dispatch of `as.environment()` to the class `'hyperframe'` (Appendix @sec-dont-asenvironment-hyperframe).
-   an `S4` method dispatch of `merge()` to the classes `'hyperframe'` and/or `'groupedHyperframe'` (Appendix @sec-dont-merge-hyperframe).

### `S3` methods in package **`spatstat.geom`**

Several `S3` method dispatches to the class `'hyperframe'` in package **`spatstat.geom`** behave *very differently* from their counterpart in vanilla R. Users are strongly advised to read the documentation of these functions from package **`spatstat.geom`**.

<details>

<summary>**Review**: `S3` methods `*.hyperframe()` that are drastically different from `*.data.frame()` or `*.default()`</summary>

| Generic Function | Method Dispatch to `'data.frame'` | Method Dispatch to `'hyperframe'` |
|------------------------|------------------------|------------------------|
| [`` base::`[` ``](https://search.r-project.org/R/refmans/base/html/Extract.html) | [`` base::`[.data.frame` ``](https://search.r-project.org/R/refmans/base/html/Extract.data.frame.html) | [`` spatstat.geom::`[.hyperframe` ``](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/Extract.hyperframe.html) |
| [`` base::`$<-` ``](https://search.r-project.org/R/refmans/base/html/Extract.html) | [`` base::`$<-.data.frame` ``](https://search.r-project.org/R/refmans/base/html/Extract.data.frame.html) | [`` spatstat.geom::`$<-.hyperframe` ``](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/Extract.hyperframe.html) |
| [`base::subset`](https://search.r-project.org/R/refmans/base/html/subset.html) | [`base::subset.data.frame`](https://search.r-project.org/R/refmans/base/html/subset.html) | [`spatstat.geom::subset.hyperframe`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/subset.hyperframe.html) |
| [`base::with`](https://search.r-project.org/R/refmans/base/html/with.html) | [`base::with.default`](https://search.r-project.org/R/refmans/base/html/with.html) | [`spatstat.geom::with.hyperframe`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/with.hyperframe.html) |
| [`base::within`](https://search.r-project.org/R/refmans/base/html/with.html) | [`base::within.data.frame`](https://search.r-project.org/R/refmans/base/html/with.html) | do not exist (as of v`r packageVersion('spatstat.geom')`) |

: `S3` methods `*.hyperframe()` that are drastically different from `*.data.frame()` or `*.default()`

</details>

### Convert to `groupedHyperframe` {#sec-asgroupedHyperframe-hyperframe}

The `S3` method dispatch `as.groupedHyperframe.hyperframe()` converts a `hyperframe` into a `groupedHyperframe`. This function simply inspects and adds a (nested) grouping structure to the input `hyperframe`. Data set *`osteo`* from package **`spatstat.data`** has the serial number of sampling volume `brick` nested in the bone sample `id`, i.e., a nested grouping structure `~id/brick`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: `as.groupedHyperframe.hyperframe()`'
spatstat.data::osteo |> 
  as.groupedHyperframe(group = ~ id/brick)
```

### Superimpose Multiple `hyperframe`s

The S3 method dispatch `superimpose.hyperframe()`, which does not exist in package **`spatstat.geom`** as of v`r packageVersion('spatstat.geom')`, superimposes multiple `hyperframe`s if-and-only-if they have `identical`

-   `dim`ensions, i.e., `spatstat.geom::dim.hyperframe()`
-   columns, i.e., `unclass(.)$df`
-   `names` and `class` of the `hypercolumn`s, i.e., `unclass(.)$hypercolumns`

The S3 method dispatch `superimpose.groupedHyperframe()` superimposes multiple `groupedHyperframe`s if-and-only-if they satisfy the *additional* criteria that they have `identical`

-   grouping structures, i.e., `attr(., 'group')`

We use a subset of the data set *`flu`* from package **`spatstat.data`** to illustrate the superimpose of `hyperframe`s.

```{r}
#| label: fluM
#| code-fold: true
#| code-summary: '**Data**: a `hyperframe` object *`fluM`*'
fluM = spatstat.data::flu |>
  spatstat.geom::subset.hyperframe(subset = (stain == 'M2-M1') & (virustype == 'wt'))
fluM
```

The `hyperframe` *`fluM`* contains `r nrow(fluM)` subjects, each of them has a `ppp.object` with 200-500 points.

```{r}
#| code-fold: true
#| code-summary: '**Review**: number of points per `ppp.object` in hypercolumn *`fluM$pattern`*'
fluM$pattern |>
  sapply(FUN = spatstat.geom::npoints)
```

```{r}
#| code-fold: true
#| code-summary: '**Review**: number of *`M1`* and/or *`M2`* points per `ppp.object` in hypercolumn *`fluM$pattern`*'
fluM$pattern |>
  sapply(FUN = \(i) {
    i |> 
      spatstat.geom::marks.ppp() |> 
      table()
  }) |>
  addmargins()
```

We create a `hyperframe` *`fluM1`* which consists of the same columns as *`fluM`*, but a `ppp`-hypercolumn *`pattern`* with *`M1`* marks only. Similarly, we create another `hyperframe` *`fluM2`* which consists of the *`M2`* marks only. Note that as of package **`spatstat.geom`** v`r packageVersion('spatstat.geom')`, the tedious code below is the only way to insure that we do **not** use the row names of hyperframe as the element-names of the hypercolumns. In other words, function `unclass()` avoids invoking the `S3` method dispatch `` spatstat.geom::`$.hyperframe` ``. The `S3` method dispatch `` spatstat.geom::`$<-.hyperframe` `` is fine in this application.

```{r}
#| code-fold: true
#| code-summary: '**Data**: two `hyperframe` objects *`fluM1`* and *`fluM2`*'
fluM1 = fluM2 = fluM
fluM1$pattern = unclass(fluM)$hypercolumns$pattern |> 
  spatstat.geom::solapply(FUN = spatstat.geom::subset.ppp, subset = (marks == 'M1'))
fluM2$pattern = unclass(fluM)$hypercolumns$pattern |> 
  spatstat.geom::solapply(FUN = spatstat.geom::subset.ppp, subset = (marks == 'M2'))
```

```{r}
#| code-fold: true
#| code-summary: '**Review**: number of *`M1`* points per `ppp.object` in hypercolumn *`fluM1$pattern`*'
fluM1$pattern |>
  sapply(FUN = spatstat.geom::npoints)
```

```{r}
#| code-fold: true
#| code-summary: '**Review**: number of *`M2`* points per `ppp.object` in hypercolumn *`fluM2$pattern`*'
fluM2$pattern |>
  sapply(FUN = spatstat.geom::npoints)
```

The `S3` method dispatch `superimpose.hyperframe()` recreates the `hyperframe` *`fluM`* by combining the `hyperframe`s *`fluM2`* and *`fluM1`*. Note that the order of *`fluM2`*-then-*`fluM1`* matters, because the points are arranged in *`M2`*-then-*`M1`* in the original hypercolumn *`fluM$pattern`*.

```{r}
#| code-fold: true
#| code-summary: '**Example**: `superimpose.hyperframe()`'
fluS = superimpose.hyperframe(fluM2, fluM1)
stopifnot(identical(fluS, fluM))
```

## On `anylist`

Function `spatstat.geom::anylist()` returns an object of `S3` class `'anylist'`, which `inherits` from the class `'listof'`.

We discuss some extensions of the class `'anylist'` in this section.

### On `solist`

Function `spatstat.geom::solist()` returns an object of `S3` class `'solist'`, which `inherits` from the class `'anylist'`.

The authors plan [**not**]{style="background-color: #FFFF00"} to implement

-   an `S3` method dispatch of `marks()` to the class `'solist'` (Appendix @sec-dont-marks-solist).

### Derived Class `'vectorlist'` {#sec-vectorlist}

The derived class `'vectorlist'`, i.e., a `listof` `vector`s, `inherits` from the class `'anylist'`. The implementation of the class `'vectorlist'` is inspired by the class `'solist'`. We use the `character`-hypercolumn *`values`* of data set *`Kovesi`* from package **`spatstat.data`** to illustrate this concept.

```{r}
#| code-fold: true
#| code-summary: '**Data**: a `hyperframe` object *`Kovesi`*'
spatstat.data::Kovesi |>
  head()
```

The `character`-hypercolumn *`Kovesi$values`* has the class `'anylist'`. This is a `length`-41 `listof` `character` `vector`s of equi-`length`, i.e., all `vector`-elements have `length`-256.

```{r}
#| code-fold: true
#| code-summary: '**Data**: an `anylist` object *`Kovesi$values`*'
spatstat.data::Kovesi$values |>
  class()
spatstat.data::Kovesi$values |>
  length()
spatstat.data::Kovesi$values |>
  lengths() |>
  unique.default()
```

Now we create an object *`Kovesi_values`* of a derived class `'vectorlist'`.

```{r}
#| code-fold: true
#| code-summary: '**Data**: a `vectorlist` object *`Kovesi_values`*'
Kovesi_values = spatstat.data::Kovesi$values
class(Kovesi_values) = c('vectorlist', class(Kovesi_values))
Kovesi_values |> 
  class()
```

The `S3` method dispatch `t.vectorlist()` transposes a `vectorlist` of equi-`length` into another `vectorlist`, but with the `length` and `lengths` of the input switched. The use of the term "transpose", and the extension of the generic function `base::t()`, mirrors the use of the default dispatch `base:::t.default()` to transpose a `matrix`, i.e., to switch the `ncol` and `nrow` of the input. The returned object *`Kovesi_values_t`* is a `length`-256 `listof` `vector`s, all elements of which have `length`-41.

```{r}
#| code-fold: true
#| code-summary: '**Example**: `t.vectorlist()`'
#| label: t-vectorlist
Kovesi_values_t = Kovesi_values |> 
  t()
Kovesi_values_t |>
  class()
Kovesi_values_t |>
  length()
Kovesi_values_t |>
  lengths() |>
  unique.default()
```

The motivation of the derived class `'vectorlist'` and the `S3` method dispatch `t.vectorlist()` is that the function `spatstat.geom::with.hyperframe()` could be slow in a batch process.

```{r}
#| code-fold: true
#| code-summary: 'Transposed element 1'
z1 = spatstat.data::Kovesi |> 
  spatstat.geom::with.hyperframe(expr = values[1L])
stopifnot(identical(Kovesi_values_t[[1L]], z1))
```

```{r}
#| code-fold: true
#| code-summary: 'Transposed element 2'
z2 = spatstat.data::Kovesi |> 
  spatstat.geom::with.hyperframe(expr = values[2L])
stopifnot(identical(Kovesi_values_t[[2L]], z2))
```

```{r}
#| code-fold: true
#| code-summary: 'Transposed element 256'
z256 = spatstat.data::Kovesi |> 
  spatstat.geom::with.hyperframe(expr = values[256L])
stopifnot(identical(Kovesi_values_t[[256L]], z256))
```

The derived class `'vectorlist'` is not part of package **`spatstat.geom`** as of dev v`r packageVersion('spatstat.geom')`. Users may call the `S3` method dispatch `t.vectorlist()` explicitly as a workaround before package **`spatstat.geom`** (ever) implements the class `vectorlist`.

```{r}
#| code-fold: true
#| code-summary: "**Workaround**: without derived class `'vectorlist'`"
Kovesi_values_t2 = spatstat.data::Kovesi$values |>
  t.vectorlist()
stopifnot(identical(Kovesi_values_t, Kovesi_values_t2))
```

## On `fv.object`

Many functions in package **`spatstat.explore`** call the workhorse function `spatstat.explore::fv()` and return an `fv.object`, i.e., an object with `S3` class `'fv'`. In addition to

```{r}
#| message: false
#| code-fold: true
#| code-summary: 'The `S3` method dispatches to `fv.object` defined in package **`spatstat.explore`**'
library(spatstat.explore)
methods(class = 'fv') |> 
  attr(which = 'info', exact = TRUE) |>
  subset(subset = from == 'spatstat.explore')
```

Package **`groupedHyperframe`** implements

```{r}
#| code-fold: true
#| code-summary: 'Additional `S3` method dispatches to `fv.object`'
methods(class = 'fv') |> 
  attr(which = 'info', exact = TRUE) |>
  subset(subset = from == 'groupedHyperframe') |>
  knitr::kable(label = 'tbl-S3_fv', caption = '`S3` method dispatches to class `\'fv\'`')
```

### "Black Solid Curve" {#sec-blackSolidCurve}

The `S3` method dispatch `spatstat.explore::plot.fv()` visualizes the function values stored in an `fv.object` as a black-solid-curve.

```{r}
#| fig-show: hide
#| code-fold: true
#| code-summary: '**Review**: `spatstat.explore::plot.fv()`'
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  spatstat.explore::plot.fv()
# Figure suppressed to reduce vignette file size
```

Function `key1.fv()` finds the "name" of the function values in an `fv.object`. Function `key1.fv()`, named after the code snippet `key[lty == 1L & col == 1L]`, is a "psuedo" `S3` method dispatch, i.e., named in the fashion of `<generic>.<class>`, because we do not have an `S3` generic function `key1()` defined as of package **`groupedHyperframe`** v`r packageVersion('groupedHyperframe')`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: `key1.fv()`'
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  key1.fv()
```

Function `key1val.fv()` finds the function values in an `fv.object`, with the corresponding $r$-values as the `vector` `names`. Function `key1val.fv()` is also a "psuedo" `S3` method dispatch, because we do not have an `S3` generic function `key1val()` defined as of package **`groupedHyperframe`** v`r packageVersion('groupedHyperframe')`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: `key1val.fv()`'
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  key1val.fv() |>
  head(n = 3L)
```

Functions `trapz.fv()` and `cumtrapz.fv()` calculate the (cumulative) trapezoidal integration (Appendix @sec-trapz) under the black-solid-curve. They are both "psuedo" `S3` method dispatches, as the workhorse functions `pracma::trapz()` and `pracma::cumtrapz()` are not `S3` generic functions as of package **`pracma`** v`r packageVersion('pracma')`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: `trapz.fv()`'
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  trapz.fv()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: `cumtrapz.fv()`'
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  cumtrapz.fv() |>
  tail(n = 3L)
```

Functions `vtrapz.fv()` and `cumvtrapz.fv()` calculate the (cumulative) average vertical height of the trapezoidal integration (Appendix @sec-vtrapz) under the black-solid-curve. They are both "psuedo" `S3` method dispatches, as the workhorse functions `vtrapz()` and `cumvtrapz()` are not `S3` generic functions as of package **`groupedHyperframe`** v`r packageVersion('groupedHyperframe')`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: `vtrapz.fv()`'
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  vtrapz.fv()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: `cumvtrapz.fv()`'
spatstat.data::spruces |> 
  spatstat.explore::markcorr() |>
  cumvtrapz.fv() |>
  tail(n = 3L)
```

### Legal $r_\text{max}$ {#sec-legal_rmax}

Function `spatstat.explore::markcorr()` is the workhorse inside functions `Emark()`, `Vmark()` and `markvario()` as of package **`spatstat.explore`** v`r packageVersion('spatstat.explore')`.

Function `markcorr()` relies on the un-exported workhorse function `spatstat.explore:::sewsmod()`, whose default `method = "density"` contains the calculation of the ratio of two kernel densities. Due to the floating-point precision of R, such density ratios may have exceptional/illegal returns of

-   `0`, from $0/\delta$, with a [real number](https://en.wikipedia.org/wiki/Real_number) $\delta\geq$ (approximately) `2.6e-324`
-   `NaN`, from $0/\varepsilon$ or $\varepsilon/0$, with a real number $\varepsilon\leq$ (approximately) `2.5e-324`
-   `Inf`, from $\delta/0$, with a real number $\delta\geq$ (approximately) `2.6e-324`

```{r}
#| code-fold: true
#| code-summary: "**Review**: exceptional/illegal ratio due to floating-point precision"
0 / c(2.6e-324, 2.5e-324)
c(2.5e-324, 2.6e-324) / 0
```

Function `markcorr()` provides a default argument of parameter $r$ (Appendix @sec-default_rmax), at which the mark correlation function $k_f(r)$ are evaluated. The S3 method dispatch `spatstat.explore::print.fv()` prints the *recommended range* and *available range* of $r$.

```{r}
#| code-fold: true
#| code-summary: "**Review**: `spatstat.explore::print.fv()`"
spatstat.data::spruces |> 
  spatstat.explore::markcorr()
```

We may observe exceptional/illegal values `0`, `NaN` and `Inf` in the mark correlation function $k_f(r)$, if $r$ goes beyond the recommended and/or available range.

```{r}
#| code-fold: true
#| code-summary: "**Review**: exceptional/illegal function values *`iso`* when $r$ is out-of-range"
fv = spatstat.data::spruces |> 
  spatstat.explore::markcorr(r = 0:100)
fv |>
  spatstat.explore::as.data.frame.fv() |>
  utils::tail(n = 30L)
```

Function `lastLegal()` provides the *index* of the last legal function value in an `fv.object`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: `lastLegal()`'
fv |>
  key1val.fv() |>
  lastLegal()
```

## On `ppp.object`

Function `spatstat.geom::ppp()` returns a `ppp.object`, i.e., an object with `S3` class `'ppp'`. In addition to

```{r}
#| message: false
#| code-fold: true
#| code-summary: 'The `S3` method dispatches to `ppp.object` defined in package **`spatstat.geom`**'
library(spatstat.geom)
methods(class = 'ppp') |> 
  attr(which = 'info', exact = TRUE) |>
  subset(subset = from == 'spatstat.geom')
```

Package **`groupedHyperframe`** implements

```{r}
#| code-fold: true
#| code-summary: 'Additional `S3` method dispatches to `ppp.object`'
methods(class = 'ppp') |> 
  attr(which = 'info', exact = TRUE) |>
  subset(subset = from == 'groupedHyperframe') |> 
  knitr::kable(label = 'tbl-S3_ppp', caption = '`S3` method dispatches to class `\'ppp\'`')
```

### Append to Existing `marks`

The `S3` generic syntactic sugar `append_marks<-()` appends an additional mark to the existing `marks`.

The `S3` method dispatch `append_marks<-.ppp()` appends an additional mark to the existing `marks` of an `ppp.object`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: `append_marks<-.ppp()`, no existing marks'
data(vesicles, package = 'spatstat.data')
vesicles |> spatstat.geom::print.ppp()
set.seed(12); append_marks(vesicles) = rlnorm(n = spatstat.geom::npoints(vesicles))
vesicles |> spatstat.geom::print.ppp()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: `append_marks<-.ppp()`, existing numeric marks'
data(waka, package = 'spatstat.data')
waka |> spatstat.geom::print.ppp()
set.seed(23); append_marks(waka) = rlnorm(n = spatstat.geom::npoints(waka))
waka |> spatstat.geom::print.ppp()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: `append_marks<-.ppp()`, existing `multitype` marks'
data(urkiola, package = 'spatstat.data')
urkiola |> spatstat.geom::print.ppp()
set.seed(42); append_marks(urkiola) = rlnorm(n = spatstat.geom::npoints(urkiola))
urkiola |> spatstat.geom::print.ppp()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: `append_marks<-.ppp()`, existing `dataframe` marks'
data(stonetools, package = 'spatstat.data')
stonetools |> spatstat.geom::print.ppp()
set.seed(33); append_marks(stonetools) = rlnorm(n = spatstat.geom::npoints(stonetools))
stonetools |> spatstat.geom::print.ppp()
```

### Log of `numeric` `marks`

The `S3` method dispatches `log.ppp()` and `log1p.ppp()` perform `log`- and $\log(x+1)$-transformation on numeric `marks`, respectively.

```{r}
#| code-fold: true
#| code-summary: '**Example**: `log.ppp()` on numeric-`marks`'
spatstat.data::longleaf
spatstat.data::longleaf |>
  spatstat.geom::marks.ppp() |>
  range()
spatstat.data::longleaf |> 
  log() |>
  spatstat.geom::marks.ppp() |>
  range()
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: `log1p.ppp()` on numeric-`marks`'
spatstat.data::bronzefilter
spatstat.data::bronzefilter |>
  spatstat.geom::marks.ppp() |>
  range()
spatstat.data::bronzefilter |> 
  log1p() |>
  spatstat.geom::marks.ppp() |>
  range()
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: `log.ppp()` on numeric-`marks` when `markformat` being `'dataframe'`"
spatstat.data::betacells
spatstat.data::betacells |>
  spatstat.geom::marks.ppp() |>
  with(expr = area) |>
  range()
spatstat.data::betacells |> 
  log() |>
  spatstat.geom::marks.ppp() |>
  with(expr = area) |>
  range()
```

### Remove Missing `marks`

The `S3` method dispatch `na.omit.ppp()` removes missing `marks` from a `ppp.object`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: `na.omit.ppp()`'
spatstat.data::nbfires |> 
  spatstat.geom::npoints()
spatstat.data::nbfires |> 
  na.omit() |> 
  spatstat.geom::npoints()
```

### Default $r_\text{max}$ {#sec-default_rmax}

The `S3` generic function `rmax_()` provides the default $r_\text{max}$ used in package **`spatstat.explore`** functions that returns an `fv.object`.

The primary `S3` method dispatch `rmax_.ppp()` is

<details>

<summary>An off-label use of functions `spatstat.explore::rmax.rule()` and `spatstat.geom::handle.r.b.args()`</summary>

| Function in package **`spatstat.explore`** | Call of `spatstat.explore::rmax.rule` | Default $r_\text{max}$ via `rmax_()` |
|------------------------|------------------------|------------------------|
| [`Emark` and `Vmark`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Emark.html), [`markcorr`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/markcorr.html), [`markvario`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/markvario.html) | `rmax.rule(fun = 'K', ...)` | `rmax_(fun = 'K')` |
| [`Kcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Kcross.html) , workhorse `Kest` and `Kmulti` | `rmax.rule(fun = 'K', ...)` | `rmax_(fun = 'K')` or `rmax_(fun = 'K', i, j)` |
| [`Gcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Gcross.html), workhorse `Gest` and `Gmulti` | `rmax.rule(fun = 'G', ...)` | `rmax_(fun = 'G')` or `rmax_(fun = 'G', i, j)` |
| [`Jcross`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/Jcross.html), workhorse `Jest` and `Jmulti` | `rmax.rule(fun = 'J', ...)` | `rmax_(fun = 'J')` or `rmax_(fun = 'J', i, j)` |

: Default $r_\text{max}$ from functions in package **`spatstat.explore`** that return an `fv.object`

</details>

The `S3` method dispatch `rmax_.ppp()` finds the default $r_\text{max}$ used by various functions applicable to `ppp.object` and returning an `fv.object`.

```{r}
#| code-fold: true
#| code-summary: "**Example**: `rmax_.ppp()`; function `spatstat.explore::markcorr()` on `double`-mark"
spatstat.data::spruces
r1 = spatstat.data::spruces |>
  spatstat.explore::markcorr() |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2 = spatstat.data::spruces |> 
  rmax_(fun = 'K')
stopifnot(identical(r1, r2))
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: `rmax_.ppp()`; function `spatstat.explore::markcorr()` on `integer`-mark"
spatstat.data::anemones
r1 = spatstat.data::anemones |>
  spatstat.explore::markcorr() |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2 = spatstat.data::anemones |> 
  rmax_(fun = 'K')
stopifnot(identical(r1, r2))
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: `rmax_.ppp()`; function `spatstat.explore::Gcross()` on `multitype`-mark"
spatstat.data::amacrine
r1a = spatstat.data::amacrine |>
  spatstat.explore::Gcross(i = 'on', j = 'off') |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2a = spatstat.data::amacrine |> 
  rmax_(fun = 'G', i = 'on', j = 'off')
stopifnot(identical(r1a, r2a))
r1b = spatstat.data::amacrine |>
  spatstat.explore::Gcross(i = 'off', j = 'on') |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2b = spatstat.data::amacrine |> 
  rmax_(fun = 'G', i = 'off', j = 'on')
stopifnot(identical(r1b, r2b))
r1c = spatstat.data::amacrine |>
  spatstat.explore::Gcross(i = 'on', j = 'on') |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2c = spatstat.data::amacrine |> 
  rmax_(fun = 'G', i = 'on', j = 'on')
stopifnot(identical(r1c, r2c))
r1d = spatstat.data::amacrine |>
  spatstat.explore::Gcross(i = 'off', j = 'off') |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2d = spatstat.data::amacrine |> 
  rmax_(fun = 'G', i = 'off', j = 'off')
stopifnot(identical(r1d, r2d))
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: `rmax_.ppp()`; function `spatstat.explore::Jcross()` on `multitype`-mark"
spatstat.data::paracou
r1a = spatstat.data::paracou |>
  spatstat.explore::Jcross(i = 'adult', j = 'juvenile') |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2a = spatstat.data::paracou |> 
  rmax_(fun = 'J', i = 'adult', j = 'juvenile')
stopifnot(identical(r1a, r2a))
r1b = spatstat.data::paracou |>
  spatstat.explore::Jcross(i = 'juvenile', j = 'adult') |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2b = spatstat.data::paracou |> 
  rmax_(fun = 'J', i = 'juvenile', j = 'adult')
stopifnot(identical(r1b, r2b))
r1c = spatstat.data::paracou |>
  spatstat.explore::Gcross(i = 'juvenile', j = 'juvenile') |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2c = spatstat.data::paracou |> 
  rmax_(fun = 'G', i = 'juvenile', j = 'juvenile')
stopifnot(identical(r1c, r2c))
r1d = spatstat.data::paracou |>
  spatstat.explore::Gcross(i = 'adult', j = 'adult') |>
  spatstat.explore::with.fv(expr = r) |>
  max()
r2d = spatstat.data::paracou |> 
  rmax_(fun = 'G', i = 'adult', j = 'adult')
stopifnot(identical(r1d, r2d))
```

The `S3` method dispatches `rmax_.ppplist()` and `rmax_.hyperframe()` obtain the default $r_\text{max}$ *before* the (potentially) very slow batch processes.

```{r}
#| code-fold: true
#| code-summary: "**Example**: `rmax_.hyperframe()`; functions `Emark_()`, `Vmark_()`, `markcorr_()`, `markvario_()` on numeric (and `multitype`) mark"
s |> rmax_(fun = 'K')
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: `rmax_.hyperframe()`; function `Kcross_()` on `multitype` mark"
s |> rmax_(fun = 'K', i = 'CK+.CD8-', j = 'CK-.CD8+')
s |> rmax_(fun = 'K', i = 'CK-.CD8+', j = 'CK+.CD8-')
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: `rmax_.hyperframe()`; function `Gcross_()` on `multitype` mark"
s |> rmax_(fun = 'G', i = 'CK+.CD8-', j = 'CK-.CD8+')
s |> rmax_(fun = 'G', i = 'CK-.CD8+', j = 'CK+.CD8-')
```

```{r}
#| code-fold: true
#| code-summary: "**Example**: `rmax_.hyperframe()`; function `Jcross_()` on multitype mark"
s |> rmax_(fun = 'J', i = 'CK+.CD8-', j = 'CK-.CD8+')
s |> rmax_(fun = 'J', i = 'CK-.CD8+', j = 'CK+.CD8-')
```

### $k$-Means Clustering {#sec-kmeans}

The `S3` generic function `.kmeans()` performs $k$-means clustering. We name this generic function with a prefix `.` because the workhorse function `stats::kmeans()` is not an `S3` generic function. The `S3` generic function `.kmeans()` returns an object of class `'kmeans'` defined in R package **`stats`** shipped with `r R.version$version.string`. Currently only one `S3` method dispatch `.kmeans.ppp()` is planned.

The `S3` method dispatch `.kmeans.ppp()` has parameters

-   `formula`, $x$- and/or $y$- coordinate(s) and/or (one or more of the) numeric `marks`
-   (optional) `centers`, number of clusters
-   (optional) `clusterSize`, "expected" number of points per cluster.

User should specify one of the two optional parameters `centers` and `clusterSize`. If both are specified, then parameter `clusterSize` takes priority and parameter `centers` is ignored.

Data set *`bei`* from package **`spatstat.data`** has $x$- and $y$-coordinates only, i.e., no `marks`.

```{r}
#| code-fold: true
#| code-summary: '**Data**: `bei`'
spatstat.data::bei
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: `.kmeans.ppp()`; cluster *`bei`* by `~ x`'
spatstat.data::bei |> 
  .kmeans(formula = ~ x, centers = 3L)
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: `.kmeans.ppp()`; cluster *`bei`* by `~ x + y`'
spatstat.data::bei |> 
  .kmeans(formula = ~ x + y, centers = 3L)
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: `.kmeans.ppp()`; cluster *`bei`* by `~ x + y` and parameter `clusterSize`'
spatstat.data::bei |> 
  .kmeans(formula = ~ x + y, clusterSize = 1000L)
```

Data set *`waka`* from package **`spatstat.data`** has numeric `marks` stored in `'vector'`-format.

```{r}
#| code-fold: true
#| code-summary: '**Data**: `waka`'
spatstat.data::waka
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: `.kmeans.ppp()`; cluster *`waka`* by `~ x + marks`'
spatstat.data::waka |> 
  .kmeans(formula = ~ x + marks, centers = 3L)
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: `.kmeans.ppp()`; cluster *`waka`* by `~ x + y + marks`'
spatstat.data::waka |> 
  .kmeans(formula = ~ x + y + marks, centers = 3L)
```

Data set *`shapley`* from package **`spatstat.data`** has three (3) numeric `marks` stored in `'dataframe'`-format.

```{r}
#| code-fold: true
#| code-summary: '**Data**: `shapley`'
spatstat.data::shapley
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: `.kmeans.ppp()`; cluster *`shapley`* by `~ x + y + Mag`'
spatstat.data::shapley |> 
  .kmeans(formula = ~ x + y + Mag, centers = 3L)
```

```{r}
#| code-fold: true
#| code-summary: '**Example**: `.kmeans.ppp()`; cluster *`shapley`* by `~ x + Mag + V`'
spatstat.data::shapley |> 
  .kmeans(formula = ~ x + Mag + V, centers = 3L)
```

#### Split by $k$-Means Clustering

The `S3` generic function `split_kmeans()` splits `ppp.object`, `ppplist`, and `hyperframe` by $k$-means clustering. We use a subset of the data set *`flu`* from package **`spatstat.data`** to illustrate the various `S3` method dispatches of `split_kmeans()`.

```{r}
#| code-fold: true
#| code-summary: '**Data**: a `hyperframe` object *`fluM`*'
<<fluM>>
```

The `S3` method dispatch `split_kmeans.default()` splits a `ppp.object` by $k$-means clustering.

```{r}
#| code-fold: true
#| code-summary: '**Example**: `split_kmeans.default()`'
fluM$pattern[[1L]] |> 
  split_kmeans(formula = ~ x + y, centers = 3L)
```

The `S3` method dispatch `split_kmeans.listof()` splits a `ppplist`, i.e., a `listof` `ppp.object`s by $k$-means clustering. The returned object has `attributes`

-   `attr(.,'.id')`, indices of the `ppp.object`s before splitting.
-   `attr(.,'.cluster')`, indices of $k$-means clusters, nested in `.id`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: `split_kmeans.listof()`'
fluM$pattern |> 
  split_kmeans(formula = ~ x + y, centers = 3L) 
```

The `S3` method dispatch `split_kmeans.hyperframe()` splits a `hyperframe` and/or `groupedHyperframe` by $k$-means clustering of the *one-and-only-one* `ppp`-hypercolumn. The returned object is a `groupedHyperframe` with grouping structure

-   `~.id/.cluster`, if the input is a `hyperframe`
-   `~ <existing/grouping/structure>/.cluster`, if the input is a `groupedHyperframe`. Note that the grouping level `.id` is **believed** to be equivalent to *the lowest level of existing grouping structure*.

```{r}
#| code-fold: true
#| code-summary: '**Example**: `split_kmeans.hyperframe()`'
fluM |> 
  split_kmeans(formula = ~ x + y, centers = 3L)
```

### Pairwise Tj√∏stheim's Coefficient

The `S3` generic function `pairwise_cor_spatial()` calculates the nonparametric, rank-based, Tj√∏stheim's correlation coefficients [@Tjostheim78; @Hubert82] in a pairwise-combination fashion, using the workhorse function `SpatialPack::cor.spatial()` from package **`SpatialPack`** [@SpatialPack].

All `S3` method dispatches return an object of class `'pairwise_cor_spatial'`, which `inherits` from the class `'dist'` defined in package **`stats`** shipped with `r R.version$version.string`. Such inheritance enables us to make use of existing `S3` method dispatches to class `'dist'`, e.g., `stats:::print.dist()`, `stats:::as.matrix.dist()`, `stats:::format.dist()` and `stats:::labels.dist()`.  @tbl-dist explains the motivation of this inheritance, that the class `'pairwise_cor_spatial'` shares intrinsic similarity in data structure as the class `'dist'`.

|   | `'pairwise_cor_spatial'` object | `'dist'` object |
|:------------------------|:------------------------|:------------------------|
| Constant `diag`onal values | of `1`; i.e., perfect correlation | of `0`; i.e., zero distance |

: Similarity in Data Structure, `'pairwise_cor_spatial'` & `'dist'` {#tbl-dist}

The `S3` method dispatch `pairwise_cor_spatial.ppp()` finds the nonparametric Tj√∏stheim's correlation coefficients from the pairwise-combinations of all numeric `marks` in a `ppp.object`.

```{r}
#| code-fold: true
#| code-summary: '**Example**: `pairwise_cor_spatial.ppp()`'
finpines_paircor = spatstat.data::finpines |>
  pairwise_cor_spatial()
```

The `S3` method dispatch `stats:::print.dist()` displays a `'pairwise_cor_spatial'` object.

```{r}
#| code-fold: true
#| code-summary: 'A `pairwise_cor_spatial` object *`finpines_paircor`*'
finpines_paircor
```

The `S3` method dispatch `as.matrix.pairwise_cor_spatial()` returns a `matrix` of pairwise Tj√∏stheim's coefficients with `diag`onal values of 1. Note that this matrix is ***not*** a `cor`relation matrix, because Tj√∏stheim's correlation coefficient

-   is nonparametric, i.e., there is no definition of the corresponding `cov`ariance, standard deviation `sd`, nor the conversion `cov2cor` method;
-   does not provide a mathematical mechanism to ensure that this matrix is [positive definite](https://en.wikipedia.org/wiki/Definite_matrix).

```{r}
#| code-fold: true
#| code-summary: '**Example**: `as.matrix.pairwise_cor_spatial()`'
finpines_paircor |> 
  as.matrix()
```

### `r '\U1f6a7'` Global Envelope Test

`r '\U1f6a7'` This section is under construction.

# What We Don't Do

Lastly, we keep note of the features that we plan **not** to support in package **`groupedHyperframe`**. Those features are technically tedious to implement, and/or have relatively easy workaround.

## For `'hyperframe'`

### `S3` method dispatch of `as.environment()` {#sec-dont-asenvironment-hyperframe}

The authors plan [**not**]{style="background-color: #FFFF00"} to write an `S3` method dispatch `as.environment` to the class `'hyperframe'`, as it would be a simple pipeline of functions `spatstat.geom::as.list.hyperframe()` and `base::list2env()`.

```{r}
#| code-fold: true
#| code-summary: '**Workaround**: `as.environment` of `hyperframe`'
ev = spatstat.data::demohyper |> 
  spatstat.geom::as.list.hyperframe() |>
  list2env()
ev |> 
  as.list.environment() |>
  lapply(FUN = class)
```

### `S4` method dispatch of `merge()` {#sec-dont-merge-hyperframe}

The authors plan [**not**]{style="background-color: #FFFF00"} to implement an `S4` method dispatch `merge` to `hyperframe` and/or `groupedHyperframe` classes, for the obstacles explained below.

First, there is not an `S3` method dispatch `merge.hyperframe` in package **`spatstat.geom`** (as of v`r packageVersion('spatstat.geom')`);

Second, should the authors decide to implement `setMethod(f = merge, ...)` for the class `'hyperframe'`, at least two (2) `S4` method dispatches need to be written for

-   `signature = c(x = 'hyperframe', y = 'data.frame')`
-   `signature = c(x = 'hyperframe', y = 'hyperframe')`, for which the authors need to define a `match` mechanism for hypercolumns.

Lastly, should the authors decide to implement `setMethod(f = merge, ...)` for the class `'groupedHyperframe'`, at least three (3) `S4` method dispatches need to be written for

-   `signature = c(x = 'groupedHyperframe', y = 'data.frame')`
-   `signature = c(x = 'groupedHyperframe', y = 'hyperframe')`, as explained above;
-   `signature = c(x = 'groupedHyperframe', y = 'groupedHyperframe')`, for which the authors need to consider the (potentially different) grouping structures of `x` and `y` inputs.

The authors suggest using the pipeline of functions `base::merge.data.frame()` and `as.groupedHyperframe()` as a workaround.

## For `'solist'`

### `S3` method dispatch of `marks()` {#sec-dont-marks-solist}

The authors plan [**not**]{style="background-color: #FFFF00"} to implement an `S3` method dispatch `marks` to the class `'solist'`.

The data set *`btb.extra`* from package **`spatstat.data`** is a `ppplist`, which `inherits` from the class `'solist'`. The `ppp`-hypercolumn of the `hyperframe` *`flu`* from package **`spatstat.data`** is another `ppplist`.

```{r}
#| code-fold: true
#| code-summary: '**Data**: a `ppplist` object *`btb.extra`*'
spatstat.data::btb.extra
spatstat.data::btb.extra |> 
  class()
```

```{r}
#| code-fold: true
#| code-summary: '**Data**: a `ppplist` object, as `ppp`-hypercolumn, *`flu$pattern`*'
spatstat.data::flu$pattern |>
  head(n = 3L)
spatstat.data::flu$pattern |>
  class()
```

The `S3` method dispatch `spatstat.geom::marks.ppp()` obtains the `marks` in each `ppp`-element of the `ppplist` *`btb.extra`* and of the `ppp`-hypercolumn *`flu$pattern`*.

```{r}
#| code-fold: true
#| code-summary: '**Review**: `marks` in *`btb.extra$full`*'
spatstat.data::btb.extra$full |> 
  spatstat.geom::marks.ppp() |>
  head()
```

```{r}
#| code-fold: true
#| code-summary: '**Review**: `marks` in *`flu$pattern[[1L]]`*'
spatstat.data::flu$pattern[[1L]] |> 
  spatstat.geom::marks.ppp() |>
  head()
```

To obtain the `marks` from all `ppp`-elements of a `ppplist`, the authors suggest using the function `base::lapply()` as a workaround, e.g.,

```{r}
#| results: hide
#| code-fold: true
#| code-summary: '**Workaround**: `marks` in `btb.extra`'
spatstat.data::btb.extra |>
  lapply(FUN = spatstat.geom::marks.ppp)
# result suppressed to save vignette space
```

```{r}
#| results: hide
#| code-fold: true
#| code-summary: '**Workaround**: `marks` in `flu$pattern`'
spatstat.data::flu$pattern |>
  lapply(FUN = spatstat.geom::marks.ppp)
# result suppressed to save vignette space
```

# Terms & Abbreviations {#sec-terms}

## in Math {#sec-mathterm}

@tbl-mathterm presents some mathematical symbols, as well as their [LaTeX](https://www.latex-project.org) source code, used in this vignette. These symbols should be familiar to the audience with an advanced degree in mathematics.

| Symbol | [LaTeX](https://www.latex-project.org) Source | Example | Translate To |
|------------------|------------------|------------------|------------------|
| $\Delta$ | `$\Delta$` | $\Delta x_k= x_k - x_{k-1}$ | Delta-$x_k$ is defined as the difference between $x_k$ and $x_{k-1}$ |
| $\equiv$ | `$\equiv$` | $x\equiv a$ | Variable $x$ is equivalent to constant $a$ |
| $\forall$ | `$\forall$` | $\forall k$ | For all $k$ |
| $\iff$ | `$\iff$` | $A\iff B$ | $A$ is true, if and only if $B$ is true |

: Terms & Abbreviations in Mathematics {#tbl-mathterm}

## in R {#sec-Rterms}

@tbl-Rterm presents a comprehensive glossary of R terms and abbreviations used in this vignette.

R terminology and nomenclature could be *drastically different* from that of mathematics and statistics. Users are *strongly advised* to read closely from the links in @tbl-Rterm, which point to webpages on [search.r-project.org](https://search.r-project.org), [cran.r-project.org](https://cran.r-project.org), and [en.wikipedia.org](https://en.wikipedia.org).

| Term / Abbreviation | Description |
|:-----------------------------------|:-----------------------------------|
| CRAN, R | The Comprehensive R Archive Network, <https://cran.r-project.org> |
| `Depends`, `Imports`, `Suggests`, `Enhances` | [*Writing R Extensions*, Section 1.1.3 *Package Dependencies*](https://cran.r-project.org/doc/manuals/r-devel/R-exts.html#Package-Dependencies) |
| [`|>`](https://search.r-project.org/R/refmans/base/html/pipeOp.html) | Forward pipe operator introduced since R version 4.1.0 |
| `.` | Dot symbol, to denote the remaining variables contained in a [`data.frame`](https://search.r-project.org/R/refmans/base/html/data.frame.html). See [`formula`](https://search.r-project.org/R/refmans/stats/html/formula.html) and [`terms.formula`](https://search.r-project.org/R/refmans/stats/html/terms.formula.html) for details. |
| [`:`](https://search.r-project.org/R/refmans/base/html/Colon.html) | Colon operator for [`interaction`](https://search.r-project.org/R/refmans/base/html/interaction.html) of [`factor`](https://search.r-project.org/R/refmans/base/html/factor.html)s, see section *Details* of [`formula`](https://search.r-project.org/R/refmans/stats/html/formula.html) documentation |
| `/` | Forward slash operator for nested grouping structure, see section *Details* of [`formula`](https://search.r-project.org/R/refmans/stats/html/formula.html) documentation |
| [`::`](https://search.r-project.org/R/refmans/base/html/ns-dblcolon.html) | Explicitly-[namespace](https://search.r-project.org/R/refmans/base/html/ns-reflect.html)d function or object |
| [`anylist`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/anylist.html) | List of objects of any type, from package **`spatstat.geom`** |
| [`attr`](https://search.r-project.org/R/refmans/base/html/attr.html), [`attributes`](https://search.r-project.org/R/refmans/base/html/attributes.html) | Attributes |
| [`cor`, `cov`, `cov2cor`](https://search.r-project.org/R/refmans/stats/html/cor.html) | Correlation matrix, variance-covariance matrix, and their conversion |
| [`cor.spatial`](https://search.r-project.org/CRAN/refmans/SpatialPack/html/cor.spatial.html) | Tj√∏stheim's nonparametric correlation coefficient, from package **`SpatialPack`** [@SpatialPack] |
| [`data.frame`](https://search.r-project.org/R/refmans/base/html/data.frame.html) | Data frame |
| [`diag`](https://search.r-project.org/R/refmans/base/html/diag.html) | Matrix diagonals |
| [`dist`](https://search.r-project.org/R/refmans/stats/html/dist.html) | Distance matrix |
| [`ecdf`](https://search.r-project.org/R/refmans/stats/html/ecdf.html) | Empirical cumulative distribution function |
| [`environment`](https://search.r-project.org/R/refmans/base/html/environment.html), [`as.environment`](https://search.r-project.org/R/refmans/base/html/as.environment.html) | (Coerce to an) environment |
| [`eval`](https://search.r-project.org/R/refmans/base/html/eval.html) | Evaluate an R `expression` |
| [`expression`](https://search.r-project.org/R/refmans/base/html/expression.html) | Unevaluated expressions |
| [`factor`](https://search.r-project.org/R/refmans/base/html/factor.html) | Categorical object, a.k.a., factor |
| [`file.size`](https://search.r-project.org/R/refmans/base/html/file.info.html) | File size in bytes |
| (one-sided) [`formula`](https://search.r-project.org/R/refmans/stats/html/formula.html) | Formula, or [one-sided formula](https://search.r-project.org/R/refmans/stats/html/asOneSidedFormula.html) |
| [`fv`, `fv.object`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/fv.object.html), [`plot.fv`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/plot.fv.html) | (Plot of) function value table, from package **`spatstat.explore`** |
| [`ggplot`](https://search.r-project.org/CRAN/refmans/ggplot2/html/ggplot.html) | Elegant data visualisations using the grammar-of-graphics, from package **`ggplot2`** [@ggplot2] |
| [`global_envelope_test`](https://search.r-project.org/CRAN/refmans/GET/html/global_envelope_test.html) | Global envelope test, from package **`GET`** [@GET] |
| [`groupedHyperframe`](https://CRAN.R-project.org/package=groupedHyperframe) | Grouped hyper data frame |
| `hypercolumns`, [`hyperframe`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/hyperframe.html) | (Hyper columns of) hyper data frame, from package **`spatstat.geom`** |
| [`identical`](https://search.r-project.org/R/refmans/base/html/identical.html) | Exact equality in R |
| [`im`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/im.html) | Pixel image object, from package **`spatstat.geom`** |
| [`inherits`](https://search.r-project.org/R/refmans/base/html/class.html) | Class inheritance |
| [`Inf`](https://search.r-project.org/R/refmans/base/html/is.finite.html) | Positive infinity $\infty$ |
| [`kable`](https://search.r-project.org/CRAN/refmans/knitr/html/kable.html) | Tables in LaTeX, HTML, markdown and reStructuredText, from package **`knitr`** [@knitr] |
| `kerndens` | Kernel [`density`](https://search.r-project.org/R/refmans/stats/html/density.html), `stats::density.default()$y` |
| [`kmeans`](https://search.r-project.org/R/refmans/stats/html/kmeans.html) | $k$-means clustering [@kmeans] |
| [`language`](https://search.r-project.org/R/refmans/base/html/is.language.html) | R language object |
| [`length`](https://search.r-project.org/R/refmans/base/html/length.html) | Length of an object |
| [`lengths`](https://search.r-project.org/R/refmans/base/html/lengths.html) | Lengths of `list` or `vector` elements |
| [`list`](https://search.r-project.org/R/refmans/base/html/list.html), [`listof`](https://search.r-project.org/R/refmans/stats/html/listof.html) | Lists of objects |
| [`list2env`](https://search.r-project.org/R/refmans/stats/html/list2env.html) | Create an `environment` containing all `list` components as objects |
| [`.Machine`](https://search.r-project.org/R/refmans/base/html/zMachine.html) | Numerical characteristics of the machine R is running on, e.g., 32-bit integers and IEC 60559 floating-point (double precision) arithmetic |
| [`markformat`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/spatstat.geom-internal.html) | Storage mode of `marks`, from package **`spatstat.geom`** |
| [`marks`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/spatstat.geom-internal.html), [`is.marked`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/is.marked.html) | Marks of a point pattern, from package **`spatstat.geom`** |
| [`match`](https://search.r-project.org/R/refmans/base/html/match.html) | Value matching |
| [`matrix`](https://search.r-project.org/R/refmans/base/html/matrix.html) | Matrices |
| [`merge`, `merge.data.frame`](https://search.r-project.org/R/refmans/base/html/merge.html) | Merge two `data.frame`s |
| [`mc.cores`](https://search.r-project.org/R/refmans/parallel/html/mclapply.html) | Number of central processing unit (CPU) cores to use for parallel computing |
| [`message`](https://search.r-project.org/R/refmans/base/html/message.html) | Diagnostic message printed in R console |
| [`multitype`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/spatstat.geom-internal.html) | Multitype spatial object, from package **`spatstat.geom`** |
| [`NaN`](https://search.r-project.org/R/refmans/base/html/is.finite.html) | Not-a-Number |
| [`names`](https://search.r-project.org/R/refmans/base/html/names.html) | Names of an R object |
| [`ncol`, `nrow`](https://search.r-project.org/R/refmans/base/html/nrow.html) | Number of rows/columns of an [`array`](https://search.r-project.org/R/refmans/base/html/array.html) |
| [`npoints`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/npoints.html) | Number of points in a point pattern, from package **`spatstat.geom`** |
| [`numeric`](https://search.r-project.org/R/refmans/base/html/numeric.html) | numeric, i.e., [`double`](https://search.r-project.org/R/refmans/base/html/double.html)-precision object |
| [`object.size`](https://search.r-project.org/R/refmans/utils/html/object.size.html) | Memory allocation |
| `pmean`, `pmedian` | Point-wise mean and median, from package `groupedHyperframe` |
| [`pmax`, `pmin`](https://search.r-project.org/R/refmans/base/html/Extremes.html) | Point-wise maxima and minima |
| [`ppp`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/ppp.html), [`ppp.object`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/ppp.object.html) | (Marked) point pattern, from package **`spatstat.geom`** |
| `ppplist` | List of [`ppp.object`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/ppp.object.html)s, which inherits from [`solist`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/solist.html), from package **`spatstat.geom`** |
| [`quantile`](https://search.r-project.org/R/refmans/stats/html/quantile.html) | Quantile |
| [`rlnorm`](https://search.r-project.org/R/refmans/stats/html/Lognormal.html) | Random number generator for [log-normal distribution](https://en.wikipedia.org/wiki/Log-normal_distribution) |
| `S3`, `generic`, [`UseMethod`](https://search.r-project.org/R/refmans/base/html/UseMethod.html), [`methods`](https://search.r-project.org/R/refmans/utils/html/methods.html), [`getS3method`](https://search.r-project.org/R/refmans/utils/html/getS3method.html) | `S3` object oriented system, <https://adv-r.hadley.nz/s3.html> |
| `S4`, [`isS4`](https://search.r-project.org/R/refmans/base/html/isS4.html), [`setClass`](https://search.r-project.org/R/refmans/methods/html/setClass.html), [`setGeneric`](https://search.r-project.org/R/refmans/methods/html/setGeneric.html), [`setMethod`](https://search.r-project.org/R/refmans/methods/html/setMethod.html), [`getMethod`](https://search.r-project.org/R/refmans/methods/html/getMethod.html) | `S4` object oriented system, <https://adv-r.hadley.nz/s4.html>, implemented in package **`methods`** shipped with vanilla `r R.version.string` |
| `S7`, [`new_generic`](https://search.r-project.org/CRAN/refmans/S7/html/new_generic.html), [`method`](https://search.r-project.org/CRAN/refmans/S7/html/method.html) | `S7` object oriented system, a successor to `S3` and `S4`, <https://rconsortium.github.io/S7>, currently in package **`S7`** [@S7] |
| [`save`](https://search.r-project.org/R/refmans/base/html/save.html), [`saveRDS`](https://search.r-project.org/R/refmans/base/html/readRDS.html), `xz` | Save with [`xz`](https://en.wikipedia.org/wiki/XZ_Utils) compression |
| [`sd`](https://search.r-project.org/R/refmans/stats/html/sd.html) | Standard deviation |
| [`search`](https://search.r-project.org/R/refmans/base/html/search.html) | Search path |
| [`signature`](https://search.r-project.org/R/refmans/methods/html/GenericFunctions.html) | Tools for managing `S4` generic functions |
| [`solist`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/solist.html) | List of two-dimensional spatial objects, from package **`spatstat.geom`** |
| [`split`](https://search.r-project.org/R/refmans/base/html/split.html) | Divide into groups |
| [`stopifnot`](https://search.r-project.org/R/refmans/base/html/stopifnot.html) | To ensure the truth of R [`expression`](https://search.r-project.org/R/refmans/base/html/expression.html)s |
| [`Surv`](https://search.r-project.org/CRAN/refmans/survival/html/Surv.html) | Survival, i.e., time-to-event, object, from package **`survival`** [@survival] |
| [`symbol`, `name`](https://search.r-project.org/R/refmans/base/html/name.html) | R object name/symbol |
| [`t`, `t.default`](https://search.r-project.org/R/refmans/base/html/t.html) | Transpose |
| [`tempfile`](https://search.r-project.org/R/refmans/base/html/tempfile.html) | Create names for temporary files |
| [`trapz`, `cumtrapz`](https://search.r-project.org/CRAN/refmans/pracma/html/trapz.html) | (Cumulative) [trapezoidal integration](https://en.wikipedia.org/wiki/Trapezoidal_rule), from package **`pracma`** [@pracma] |
| [`unclass`](https://search.r-project.org/R/refmans/base/html/class.html) | Remove `S3` `'class'` attribute |
| [`vector`](https://search.r-project.org/R/refmans/base/html/vector.html) | Vector |
| [`with`, `with.default`](https://search.r-project.org/R/refmans/base/html/with.html), [`with.hyperframe`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/with.hyperframe.html) | To `eval`uate an `expression` in a local `environment`, or in *each row* of a `hyperframe` |
| [`within`, `within.data.frame`](https://search.r-project.org/R/refmans/base/html/with.html) | To `eval`uate an `expression` in a local `environment` and makes modifications to the `environment` |

: Terms & Abbreviations in R {#tbl-Rterm}

{{< pagebreak >}}

# Index of Topics

| Topic | Where to Find |
|------------------------------------|------------------------------------|
| `groupedHyperframe` | @sec-groupedHyperframe, @sec-groupedHyperframe-appendix |
| `hyperframe` | @sec-hyperframe-appendix, or package **`spatstat.geom`** documentation |
| $k$-means clustering | @sec-kmeans |
| $r_\text{max}$, default | @sec-default_rmax |
| $r_\text{max}$, legal | @sec-legal_rmax |
| trapezoidal integration | @sec-trapz |

# References

::: {#refs}
:::
